#!/bin/bash
# Test a specific git revision
# Usage: ./test-revision [commit-hash]
#        If no hash provided, shows menu to select from recent commits

set -e

cd "$(dirname "$0")/.."

# If a commit hash is provided, use it
if [ -n "$1" ]; then
    COMMIT="$1"
else
    # Show recent commits and let user pick
    echo "Recent commits on current branch:"
    echo "=================================="
    git log --oneline --decorate -20
    echo ""
    echo -n "Enter commit hash (or press Enter for HEAD): "
    read COMMIT

    if [ -z "$COMMIT" ]; then
        COMMIT="HEAD"
    fi
fi

# Validate commit exists
if ! git rev-parse "$COMMIT" >/dev/null 2>&1; then
    echo "Error: Invalid commit '$COMMIT'"
    exit 1
fi

# Get current branch and commit for restoration
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
CURRENT_COMMIT=$(git rev-parse HEAD)

echo ""
echo "Testing commit: $(git log -1 --oneline "$COMMIT")"
echo "Current state will be saved for restoration"
echo ""

# Stash any uncommitted changes
STASHED=0
if ! git diff-index --quiet HEAD --; then
    echo "Stashing uncommitted changes..."
    git stash push -m "test-revision auto-stash $(date +%Y%m%d-%H%M%S)"
    STASHED=1
fi

# Checkout the target commit
echo "Checking out $COMMIT..."
git checkout -q "$COMMIT"

# Run tests
echo ""
echo "Running regression tests..."
echo "============================"
cd test
if ./run-regression; then
    TEST_RESULT="PASSED"
    TEST_EXIT=0
else
    TEST_RESULT="FAILED"
    TEST_EXIT=1
fi

cd ..

# Restore original state
echo ""
echo "Restoring original state..."
git checkout -q "$CURRENT_BRANCH"

if [ $STASHED -eq 1 ]; then
    echo "Restoring stashed changes..."
    git stash pop -q
fi

# Print summary
echo ""
echo "============================"
echo "Test Summary"
echo "============================"
echo "Commit:  $(git log -1 --oneline "$COMMIT")"
echo "Result:  $TEST_RESULT"
echo ""

exit $TEST_EXIT
