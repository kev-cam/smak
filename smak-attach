#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket::INET;
use IO::Select;
use Cwd 'abs_path';
use Getopt::Long;

# Parse command-line options
my $target_pid;
my $target_port;
my $pid_arg;
GetOptions('pid=s' => \$pid_arg) or die "Usage: $0 [-pid <process-id>[:<port>]]\n";

# Parse PID and optional port from -pid argument
if ($pid_arg) {
    if ($pid_arg =~ /^(\d+):(\d+)$/) {
        ($target_pid, $target_port) = ($1, $2);
    } elsif ($pid_arg =~ /^(\d+)$/) {
        $target_pid = $1;
        $target_port = undef;
    } else {
        die "Invalid -pid format. Use: -pid <process-id>[:<port>]\n";
    }
}

# Find smak-jobserver processes using port files
sub find_jobservers {
    my @jobservers;

    # Scan /tmp for port files - this is the source of truth
    my @port_files = glob("/tmp/smak-jobserver-*.port");

    for my $port_file (@port_files) {
        my ($pid) = $port_file =~ /smak-jobserver-(\d+)\.port/;
        next unless $pid;

        # Check if process is still alive
        unless (-d "/proc/$pid") {
            # Stale port file
            print STDERR "Removing stale port file: $port_file\n";
            unlink $port_file;
            next;
        }

        # Read port information
        open(my $fh, '<', $port_file) or next;
        my @ports;
        while (my $line = <$fh>) {
            chomp $line;
            push @ports, $line if $line =~ /^\d+$/;
        }
        close($fh);

        next unless @ports >= 2;  # Need at least observer and master ports
        my ($observer_port, $master_port) = @ports;

        # Get process info
        my $cmdline_file = "/proc/$pid/cmdline";
        my $cmdline = '';
        if (open(my $cmd_fh, '<', $cmdline_file)) {
            $cmdline = <$cmd_fh>;
            close($cmd_fh);
            $cmdline =~ s/\0/ /g;
            $cmdline =~ s/\s+$//;
        }

        # Get working directory
        my $cwd = readlink("/proc/$pid/cwd");

        # Try to determine number of workers from lsof (count worker connections)
        my $num_workers = 0;
        my $lsof_output = `lsof -Pan -p $pid -i TCP 2>/dev/null`;
        for my $line (split /\n/, $lsof_output) {
            $num_workers++ if $line =~ /ESTABLISHED/;
        }

        push @jobservers, {
            pid => $pid,
            workers => $num_workers,
            cwd => $cwd,
            cmdline => $cmdline,
            observer_port => $observer_port,
            master_port => $master_port,
        };
    }

    return @jobservers;
}

# Find running job-master instances
my @jobservers = find_jobservers();

unless (@jobservers) {
    print STDERR "No running smak job-master instances found.\n";
    print STDERR "Check that smak is running with -j option:\n";
    print STDERR "  smak -cli -j 4\n";
    exit 1;
}

my $selected_js;

# If -pid was specified, find that specific job-master
if ($target_pid) {
    for my $js (@jobservers) {
        if ($js->{pid} == $target_pid) {
            $selected_js = $js;
            last;
        }
    }
    unless ($selected_js) {
        die "No job-master found with PID $target_pid\n";
    }
} elsif (@jobservers > 1) {
    print "Multiple smak instances found:\n";
    for (my $i = 0; $i < @jobservers; $i++) {
        my $js = $jobservers[$i];
        print "  [$i] PID $js->{pid}";
        print " - $js->{cwd}" if $js->{cwd};
        print "\n";
        print "      Workers: $js->{workers}";
        if ($js->{master_port}) {
            print ", Master port: $js->{master_port}";
        }
        print "\n";
    }
    print "Select instance (0-" . ($#jobservers) . "): ";
    my $choice = <STDIN>;
    chomp $choice;
    if ($choice =~ /^\d+$/ && $choice <= $#jobservers) {
        $selected_js = $jobservers[$choice];
    } else {
        die "Invalid selection\n";
    }
} else {
    $selected_js = $jobservers[0];
}

my $jobserver_pid = $selected_js->{pid};
my $master_port = $selected_js->{master_port};
my $observer_port = $selected_js->{observer_port};

# Use specified port if provided, otherwise prefer master port for CLI mode
my $port;
if ($target_port) {
    $port = $target_port;
} else {
    $port = $master_port || $observer_port;
}
unless ($port) {
    die "Cannot determine port for job-master (PID $jobserver_pid)\n";
}

print "Connecting to job-master (PID $jobserver_pid) on port $port...\n";

# Connect to master port
my $socket = IO::Socket::INET->new(
    PeerHost => '127.0.0.1',
    PeerPort => $port,
    Proto    => 'tcp',
    Timeout  => 5,
) or die "Cannot connect to job-master: $!\n";

$socket->autoflush(1);
print "Connected to job-master\n";

# Send environment variables
for my $key (keys %ENV) {
    next if $key =~ /^(BASH_FUNC_|_)/;
    my $val = $ENV{$key};
    $val =~ s/\n/ /g;
    print $socket "ENV $key=$val\n";
}
print $socket "ENV_END\n";

# Wait for ready signal
my $ready = <$socket>;
chomp $ready if defined $ready;
unless ($ready && $ready eq 'JOBSERVER_WORKERS_READY') {
    die "Job-master not ready (got: " . ($ready || "EOF") . ")\n";
}

print "Job-master ready. Entering CLI mode.\n";
print "Working directory: $selected_js->{cwd}\n" if $selected_js->{cwd};
print "Workers: $selected_js->{workers}\n\n";

# Enter CLI mode
use Term::ReadLine;
my $term = Term::ReadLine->new('smak-attach');

# Set up signal handler for graceful exit
my $exit_requested = 0;
local $SIG{INT} = sub { $exit_requested = 1; };

my $line;
while (!$exit_requested && defined($line = $term->readline('smak> '))) {
    chomp $line;
    $line =~ s/^\s+|\s+$//g;

    next if $line eq '';
    $term->addhistory($line) if $line =~ /\S/;

    my @words = split(/\s+/, $line);
    my $cmd = shift @words;

    if ($cmd eq 'quit' || $cmd eq 'exit' || $cmd eq 'q') {
        print "Shutting down job server...\n";
        print $socket "SHUTDOWN\n";
        my $ack = <$socket>;
        last;

    } elsif ($cmd eq 'detach') {
        print "Detaching from job server...\n";
        last;

    } elsif ($cmd eq 'help' || $cmd eq 'h' || $cmd eq '?') {
        print <<'HELP';
Available commands:
  build <target>      Build the specified target
  tasks, t            List pending and active tasks
  status              Show job server status
  files, f            List tracked file modifications (FUSE)
  list [pattern]      List all targets (optionally matching pattern)
  vars [pattern]      Show all variables (optionally matching pattern)
  deps <target>       Show dependencies for target
  kill                Kill all workers
  restart [N]         Restart workers (optionally specify count)
  detach              Detach from job server (leave it running)
  help, h, ?          Show this help
  quit, exit, q       Shut down job server and exit

Keyboard shortcuts:
  Ctrl-C              Detach from job server

HELP

    } elsif ($cmd eq 'build' || $cmd eq 'b') {
        if (@words == 0) {
            print "Usage: build <target>\n";
        } else {
            for my $target (@words) {
                print $socket "SUBMIT_JOB\n";
                print $socket "$target\n";
                print $socket ".\n";
                print $socket "cd . && make $target\n";

                # Wait for completion with interruptible reads
                my $select = IO::Select->new($socket);
                my $job_done = 0;
                while (!$exit_requested && !$job_done) {
                    if ($select->can_read(0.1)) {
                        my $response = <$socket>;
                        last unless defined $response;
                        chomp $response;
                        if ($response =~ /^OUTPUT (.*)$/) {
                            print "$1\n";
                        } elsif ($response =~ /^ERROR (.*)$/) {
                            print "❌ ERROR: $1\n";
                        } elsif ($response =~ /^WARN (.*)$/) {
                            print "⚠️  WARN: $1\n";
                        } elsif ($response =~ /^JOB_COMPLETE (.+?) (\d+)$/) {
                            my ($completed_target, $exit_code) = ($1, $2);
                            if ($exit_code == 0) {
                                print "✓ Build succeeded: $completed_target\n";
                            } else {
                                print "✗ Build failed: $completed_target (exit code $exit_code)\n";
                            }
                            $job_done = 1;
                        }
                    }
                }

                if ($exit_requested) {
                    print "\nBuild interrupted.\n";
                    last;
                }
            }
        }

    } elsif ($cmd eq 'tasks' || $cmd eq 't') {
        print $socket "LIST_TASKS\n";
        while (my $response = <$socket>) {
            chomp $response;
            last if $response eq 'TASKS_END';
            print "$response\n";
        }

    } elsif ($cmd eq 'status' || $cmd eq 'st') {
        print "Job server PID: $jobserver_pid\n";
        print "Workers: $selected_js->{workers}\n";
        print "Working directory: $selected_js->{cwd}\n" if $selected_js->{cwd};

    } elsif ($cmd eq 'kill') {
        print "Killing all workers...\n";
        print $socket "KILL_WORKERS\n";
        my $response = <$socket>;
        chomp $response if $response;
        print "$response\n" if $response;

    } elsif ($cmd eq 'restart') {
        my $count = @words > 0 ? $words[0] : $selected_js->{workers};
        print "Restarting workers ($count workers)...\n";
        print $socket "RESTART_WORKERS $count\n";
        my $response = <$socket>;
        chomp $response if $response;
        print "$response\n" if $response;

    } elsif ($cmd eq 'files' || $cmd eq 'f') {
        print $socket "LIST_FILES\n";
        while (my $response = <$socket>) {
            chomp $response;
            last if $response eq 'FILES_END';
            print "$response\n";
        }

    } elsif ($cmd eq 'list' || $cmd eq 'ls' || $cmd eq 'l') {
        print "list command not yet implemented in attach mode\n";

    } elsif ($cmd eq 'vars' || $cmd eq 'v') {
        print "vars command not yet implemented in attach mode\n";

    } elsif ($cmd eq 'deps' || $cmd eq 'd') {
        print "deps command not yet implemented in attach mode\n";

    } else {
        print "Unknown command: $cmd\n";
        print "Type 'help' for available commands.\n";
    }

    # Check for exit request from Ctrl-C
    if ($exit_requested) {
        last;
    }
}

if ($exit_requested || !defined($line)) {
    print "\nDetaching from job server.\n";
    print "Job server still running (PID $jobserver_pid).\n";
    print "To reattach: smak-attach\n";
}

close($socket);
exit 0;
