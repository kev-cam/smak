#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Term::ReadLine;
use POSIX ":sys_wait_h";

# Separate hashes for different rule types
my %fixed_rule;
my %fixed_deps;
my %pattern_rule;
my %pattern_deps;
my %pseudo_rule;
my %pseudo_deps;

# Hash for Makefile variables
my %MV;

# Track modifications for saving
my @modifications;

# Control variables
my $timeout = 5;  # Timeout for print command evaluation in seconds
my $prompt = "smak> ";  # Prompt string for interactive mode
my $echo = 0;  # Echo command lines (including prompt)

my $makefile = 'Makefile';
my $debug = 0;
my $help = 0;
my $script_file = '';

# Parse environment variable options first
if (defined $ENV{USR_SMAK_OPT}) {
    # Split the environment variable into arguments
    my @env_args = split(/\s+/, $ENV{USR_SMAK_OPT});
    # Save original @ARGV
    my @saved_argv = @ARGV;
    # Process environment options
    @ARGV = @env_args;
    GetOptions(
        'f|file|makefile=s' => \$makefile,
        'Kd|Kdebug' => \$debug,
        'Kh|Khelp' => \$help,
        'Ks|Kscript=s' => \$script_file,
    );
    # Restore and append remaining command line args
    @ARGV = @saved_argv;
}

# Parse command-line options (override environment)
GetOptions(
    'f|file|makefile=s' => \$makefile,
    'Kd|Kdebug' => \$debug,
    'Kh|Khelp' => \$help,
    'Ks|Kscript=s' => \$script_file,
) or die "Error in command line arguments\n";

# Remaining arguments are targets to build
my @targets = @ARGV;

if ($help) {
    print_help();
    exit 0;
}

sub print_help {
    print <<'HELP';
Usage: smak [options] [targets...]

Options:
  -f, -file, -makefile FILE   Use FILE as a makefile (default: Makefile)
  -Kd, -Kdebug                Enter interactive debug mode
  -Ks, -Kscript FILE          Load and execute smak commands from FILE
  -Kh, -Khelp                 Display this help message

Environment Variables:
  USR_SMAK_OPT                Options to prepend (e.g., "USR_SMAK_OPT=-Kd")

Examples:
  smak -Ks fixes.smak all     Load fixes, then build target 'all'
  USR_SMAK_OPT='-Ks fixes.smak' smak target

HELP
}

open(my $fh, '<', $makefile) or die "Cannot open $makefile: $!";

my $current_target;
my $current_rule = '';
my $current_type;  # 'fixed', 'pattern', or 'pseudo'

sub classify_target {
    my ($target) = @_;
    if ($target =~ /^\./) {
        return 'pseudo';
    } elsif ($target =~ /%/) {
        return 'pattern';
    } else {
        return 'fixed';
    }
}

sub expand_vars {
    my ($text, $depth) = @_;
    $depth ||= 0;
    return $text if $depth > 10;  # Prevent infinite recursion

    # Expand $(function args) and $(VAR) references
    while ($text =~ /\$\(([^)]+)\)/) {
        my $content = $1;
        my $replacement;

        # Check if it's a function call (contains space or comma)
        if ($content =~ /^(\w+)\s+(.+)$/ || $content =~ /^(\w+),(.+)$/) {
            my $func = $1;
            my $args_str = $2;

            # Split arguments by comma, but not within nested $()
            my @args;
            my $depth = 0;
            my $current = '';
            for my $char (split //, $args_str) {
                if ($char eq ',' && $depth == 0) {
                    push @args, $current;
                    $current = '';
                } else {
                    $current .= $char;
                    $depth++ if $char eq '(';
                    $depth-- if $char eq ')';
                }
            }
            push @args, $current if $current ne '';

            # Trim and expand each argument
            @args = map { expand_vars($_, $depth + 1) } map { s/^\s+|\s+$//gr } @args;

            # Call the gmake function
            my $func_name = "gmake_$func";
            if (defined &$func_name) {
                no strict 'refs';
                $replacement = &$func_name(@args);
            } else {
                $replacement = '';  # Unknown function
            }
        } else {
            # It's a variable reference
            $replacement = $MV{$content} || "";
        }

        # Replace the first occurrence
        $text =~ s/\$\(\Q$content\E\)/$replacement/;

        # Recursively expand if result contains $
        $text = expand_vars($text, $depth + 1) if $replacement =~ /\$/;
    }

    return $text;
}

sub format_output {
    my ($text) = @_;
    # Convert $MV{VAR} back to $(VAR) for display
    $text =~ s/\$MV\{([^}]+)\}/\$($1)/g;
    return $text;
}

# Gmake function implementations
sub gmake_subst {
    my ($from, $to, $text) = @_;
    $text =~ s/\Q$from\E/$to/g;
    return $text;
}

sub gmake_patsubst {
    my ($pattern, $replacement, $text) = @_;
    my @words = split(/\s+/, $text);

    # Convert % pattern to regex by escaping everything except %
    my @parts = split(/(%+)/, $pattern);
    my $pat = '';
    for my $part (@parts) {
        if ($part eq '%') {
            $pat .= '(.+?)';  # Non-greedy match
        } elsif ($part ne '') {
            $pat .= quotemeta($part);
        }
    }

    my @result;
    for my $word (@words) {
        if ($word =~ /^$pat$/) {
            my $stem = $1;
            my $rep = $replacement;
            $rep =~ s/%/$stem/g;
            push @result, $rep;
        } else {
            push @result, $word;
        }
    }
    return join(' ', @result);
}

sub gmake_strip {
    my ($text) = @_;
    $text =~ s/^\s+//;
    $text =~ s/\s+$//;
    $text =~ s/\s+/ /g;
    return $text;
}

sub gmake_findstring {
    my ($find, $text) = @_;
    return index($text, $find) >= 0 ? $find : '';
}

sub gmake_filter {
    my ($patterns, $text) = @_;
    my @patterns = split(/\s+/, $patterns);
    my @words = split(/\s+/, $text);
    my @result;

    for my $word (@words) {
        for my $pattern (@patterns) {
            my @parts = split(/(%+)/, $pattern);
            my $regex = '';
            for my $part (@parts) {
                if ($part eq '%') {
                    $regex .= '(.+?)';
                } elsif ($part ne '') {
                    $regex .= quotemeta($part);
                }
            }
            if ($word =~ /^$regex$/) {
                push @result, $word;
                last;
            }
        }
    }
    return join(' ', @result);
}

sub gmake_filter_out {
    my ($patterns, $text) = @_;
    my @patterns = split(/\s+/, $patterns);
    my @words = split(/\s+/, $text);
    my @result;

    for my $word (@words) {
        my $matched = 0;
        for my $pattern (@patterns) {
            my @parts = split(/(%+)/, $pattern);
            my $regex = '';
            for my $part (@parts) {
                if ($part eq '%') {
                    $regex .= '(.+?)';
                } elsif ($part ne '') {
                    $regex .= quotemeta($part);
                }
            }
            if ($word =~ /^$regex$/) {
                $matched = 1;
                last;
            }
        }
        push @result, $word unless $matched;
    }
    return join(' ', @result);
}

sub gmake_sort {
    my ($text) = @_;
    my @words = split(/\s+/, $text);
    my %seen;
    @words = grep { !$seen{$_}++ } @words;
    return join(' ', sort @words);
}

sub gmake_word {
    my ($n, $text) = @_;
    my @words = split(/\s+/, $text);
    return $words[$n - 1] || '';
}

sub gmake_wordlist {
    my ($s, $e, $text) = @_;
    my @words = split(/\s+/, $text);
    return join(' ', @words[$s - 1 .. $e - 1]);
}

sub gmake_words {
    my ($text) = @_;
    my @words = split(/\s+/, $text);
    return scalar(@words);
}

sub gmake_firstword {
    my ($text) = @_;
    my @words = split(/\s+/, $text);
    return $words[0] || '';
}

sub gmake_lastword {
    my ($text) = @_;
    my @words = split(/\s+/, $text);
    return $words[-1] || '';
}

sub gmake_dir {
    my ($names) = @_;
    my @names = split(/\s+/, $names);
    my @result;
    for my $name (@names) {
        if ($name =~ m{^(.*/)[^/]*$}) {
            push @result, $1;
        } else {
            push @result, './';
        }
    }
    return join(' ', @result);
}

sub gmake_notdir {
    my ($names) = @_;
    my @names = split(/\s+/, $names);
    my @result;
    for my $name (@names) {
        if ($name =~ m{^.*/([^/]*)$}) {
            push @result, $1;
        } else {
            push @result, $name;
        }
    }
    return join(' ', @result);
}

sub gmake_suffix {
    my ($names) = @_;
    my @names = split(/\s+/, $names);
    my @result;
    for my $name (@names) {
        if ($name =~ /(\.[^.\/]*)$/) {
            push @result, $1;
        }
    }
    return join(' ', @result);
}

sub gmake_basename {
    my ($names) = @_;
    my @names = split(/\s+/, $names);
    my @result;
    for my $name (@names) {
        my $base = $name;
        $base =~ s/\.[^.\/]*$//;
        push @result, $base;
    }
    return join(' ', @result);
}

sub gmake_addsuffix {
    my ($suffix, $names) = @_;
    my @names = split(/\s+/, $names);
    return join(' ', map { $_ . $suffix } @names);
}

sub gmake_addprefix {
    my ($prefix, $names) = @_;
    my @names = split(/\s+/, $names);
    return join(' ', map { $prefix . $_ } @names);
}

sub gmake_join {
    my ($list1, $list2) = @_;
    my @list1 = split(/\s+/, $list1);
    my @list2 = split(/\s+/, $list2);
    my @result;
    for (my $i = 0; $i < @list1 || $i < @list2; $i++) {
        push @result, ($list1[$i] || '') . ($list2[$i] || '');
    }
    return join(' ', @result);
}

sub gmake_wildcard {
    my ($pattern) = @_;
    my @files = glob($pattern);
    return join(' ', @files);
}

sub gmake_realpath {
    my ($names) = @_;
    require Cwd;
    my @names = split(/\s+/, $names);
    my @result;
    for my $name (@names) {
        my $real = Cwd::realpath($name);
        push @result, $real if $real;
    }
    return join(' ', @result);
}

sub gmake_abspath {
    my ($names) = @_;
    require Cwd;
    my @names = split(/\s+/, $names);
    my @result;
    for my $name (@names) {
        my $abs = Cwd::abs_path($name);
        push @result, $abs || $name;
    }
    return join(' ', @result);
}

sub gmake_if {
    my ($condition, $then_part, $else_part) = @_;
    $else_part ||= '';
    return $condition ? $then_part : $else_part;
}

sub gmake_or {
    my @conditions = @_;
    for my $cond (@conditions) {
        return $cond if $cond;
    }
    return '';
}

sub gmake_and {
    my @conditions = @_;
    my $last = '';
    for my $cond (@conditions) {
        return '' unless $cond;
        $last = $cond;
    }
    return $last;
}

sub save_current_rule {
    return unless $current_target;

    my $key = "$makefile\t$current_target";
    if ($current_type eq 'pseudo') {
        $pseudo_rule{$key} = $current_rule;
    } elsif ($current_type eq 'pattern') {
        $pattern_rule{$key} = $current_rule;
    } else {
        $fixed_rule{$key} = $current_rule;
    }
}

while (my $line = <$fh>) {
    chomp $line;

    # Skip comments and empty lines
    next if $line =~ /^\s*#/ || $line =~ /^\s*$/;

    # Check if this is a variable assignment (VAR = value, VAR := value, etc.)
    if ($line =~ /^([A-Za-z_][A-Za-z0-9_]*)\s*[:+]?=\s*(.*)$/ && $line !~ /^\t/) {
        my ($var, $value) = ($1, $2);
        $MV{$var} = $value;
        next;
    }

    # Check if this is a target line (contains : and doesn't start with tab)
    if ($line =~ /^([^:\s]+)\s*:\s*(.*)$/ && $line !~ /^\t/) {
        my $target = $1;
        my $dependencies = $2;

        # Save previous rule if exists
        save_current_rule();

        # Classify and start new target
        $current_target = $target;
        $current_type = classify_target($target);
        $current_rule = '';

        # Store dependencies in appropriate hash
        my $key = "$makefile\t$target";
        my @dep_list = grep { $_ ne '' } split(/\s+/, $dependencies);

        if ($current_type eq 'pseudo') {
            $pseudo_deps{$key} = \@dep_list;
        } elsif ($current_type eq 'pattern') {
            $pattern_deps{$key} = \@dep_list;
        } else {
            $fixed_deps{$key} = \@dep_list;
        }
    }
    # Check if this is a rule line (starts with tab)
    elsif ($line =~ /^\t(.*)$/) {
        my $command = $1;
        # Transform $(VAR) to $MV{VAR}
        $command =~ s/\$\(([^)]+)\)/\$MV{$1}/g;
        $current_rule .= $command . "\n";
    }
}

# Save last rule
save_current_rule();

close($fh);

# Execute script file if specified
if ($script_file) {
    execute_script($script_file);
}

# If targets specified but not in debug mode, build them
if (@targets && !$debug) {
    foreach my $target (@targets) {
        build_target($target);
    }
    exit 0;
}

# Debug mode or normal output
if ($debug) {
    interactive_debug();
} else {
    print_rules();
}

sub print_rules {
    print "Rules parsed from $makefile:\n";
    print "=" x 60 . "\n\n";

    # Print pseudo rules
    if (keys %pseudo_rule || keys %pseudo_deps) {
        print "PSEUDO RULES (.PHONY, .PRECIOUS, etc.):\n";
        print "-" x 60 . "\n";
        my %seen;
        for my $key (sort keys %pseudo_rule, keys %pseudo_deps) {
            next if $seen{$key}++;
            print "Key: $key\n";
            print "Dependencies: ", join(', ', @{$pseudo_deps{$key} || []}), "\n";
            print "Rule:\n", format_output($pseudo_rule{$key} || "(none)\n");
            print "-" x 60 . "\n";
        }
        print "\n";
    }

    # Print pattern rules
    if (keys %pattern_rule || keys %pattern_deps) {
        print "PATTERN RULES (with %):\n";
        print "-" x 60 . "\n";
        my %seen;
        for my $key (sort keys %pattern_rule, keys %pattern_deps) {
            next if $seen{$key}++;
            print "Key: $key\n";
            print "Dependencies: ", join(', ', @{$pattern_deps{$key} || []}), "\n";
            print "Rule:\n", format_output($pattern_rule{$key} || "(none)\n");
            print "-" x 60 . "\n";
        }
        print "\n";
    }

    # Print fixed rules
    if (keys %fixed_rule || keys %fixed_deps) {
        print "FIXED RULES:\n";
        print "-" x 60 . "\n";
        my %seen;
        for my $key (sort keys %fixed_rule, keys %fixed_deps) {
            next if $seen{$key}++;
            print "Key: $key\n";
            print "Dependencies: ", join(', ', @{$fixed_deps{$key} || []}), "\n";
            print "Rule:\n", format_output($fixed_rule{$key} || "(none)\n");
            print "-" x 60 . "\n";
        }
        print "\n";
    }
}

sub dry_run_target {
    my ($target, $visited, $depth) = @_;
    $visited ||= {};
    $depth ||= 0;

    return if $visited->{$target};
    $visited->{$target} = 1;

    my $key = "$makefile\t$target";
    my @deps;
    my $rule = '';

    # Find target in fixed, pattern, or pseudo rules
    if (exists $fixed_deps{$key}) {
        @deps = @{$fixed_deps{$key} || []};
        $rule = $fixed_rule{$key} || '';
    } elsif (exists $pattern_deps{$key}) {
        @deps = @{$pattern_deps{$key} || []};
        $rule = $pattern_rule{$key} || '';
    } elsif (exists $pseudo_deps{$key}) {
        @deps = @{$pseudo_deps{$key} || []};
        $rule = $pseudo_rule{$key} || '';
    } else {
        # Try to find pattern rule match
        for my $pkey (keys %pattern_rule) {
            if ($pkey =~ /^[^\t]+\t(.+)$/) {
                my $pattern = $1;
                my $pattern_re = $pattern;
                $pattern_re =~ s/%/(.+)/g;
                if ($target =~ /^$pattern_re$/) {
                    @deps = @{$pattern_deps{$pkey} || []};
                    $rule = $pattern_rule{$pkey} || '';
                    # Expand % in dependencies
                    my $stem = $1;
                    @deps = map { s/%/$stem/g; $_ } @deps;
                    last;
                }
            }
        }
    }

    # Recursively process dependencies
    for my $dep (@deps) {
        dry_run_target($dep, $visited, $depth + 1);
    }

    # Print rule if it exists
    if ($rule && $rule =~ /\S/) {
        # Convert $MV{VAR} to $(VAR) for expansion
        my $converted = format_output($rule);
        # Expand variables
        my $expanded = expand_vars($converted);
        print $expanded;
    }
}

sub build_target {
    my ($target, $visited, $depth) = @_;
    $visited ||= {};
    $depth ||= 0;

    return if $visited->{$target};
    $visited->{$target} = 1;

    my $key = "$makefile\t$target";
    my @deps;
    my $rule = '';

    # Find target in fixed, pattern, or pseudo rules
    if (exists $fixed_deps{$key}) {
        @deps = @{$fixed_deps{$key} || []};
        $rule = $fixed_rule{$key} || '';
    } elsif (exists $pattern_deps{$key}) {
        @deps = @{$pattern_deps{$key} || []};
        $rule = $pattern_rule{$key} || '';
    } elsif (exists $pseudo_deps{$key}) {
        @deps = @{$pseudo_deps{$key} || []};
        $rule = $pseudo_rule{$key} || '';
    } else {
        # Try to find pattern rule match
        for my $pkey (keys %pattern_rule) {
            if ($pkey =~ /^[^\t]+\t(.+)$/) {
                my $pattern = $1;
                my $pattern_re = $pattern;
                $pattern_re =~ s/%/(.+)/g;
                if ($target =~ /^$pattern_re$/) {
                    @deps = @{$pattern_deps{$pkey} || []};
                    $rule = $pattern_rule{$pkey} || '';
                    # Expand % in dependencies
                    my $stem = $1;
                    @deps = map { s/%/$stem/g; $_ } @deps;
                    last;
                }
            }
        }
    }

    # Recursively build dependencies
    for my $dep (@deps) {
        build_target($dep, $visited, $depth + 1);
    }

    # Execute rule if it exists
    if ($rule && $rule =~ /\S/) {
        # Convert $MV{VAR} to $(VAR) for expansion
        my $converted = format_output($rule);
        # Expand variables
        my $expanded = expand_vars($converted);

        # Expand automatic variables
        $expanded =~ s/\$@/$target/g;                     # $@ = target name
        $expanded =~ s/\$</$deps[0] || ''/ge;            # $< = first prerequisite
        $expanded =~ s/\$\^/join(' ', @deps)/ge;         # $^ = all prerequisites

        # Execute each command line
        for my $cmd_line (split /\n/, $expanded) {
            next unless $cmd_line =~ /\S/;  # Skip empty lines

            # Check if command starts with @ (silent mode)
            my $silent = ($cmd_line =~ s/^\s*@//);

            # Echo command unless silent (like make)
            print "$cmd_line\n" unless $silent;

            # Execute the command
            my $exit_code = system($cmd_line);
            if ($exit_code != 0) {
                die "smak: *** [$target] Error $exit_code\n";
            }
        }
    }
}

sub execute_script {
    my ($filename) = @_;

    open(my $script_fh, '<', $filename) or die "Cannot open script file '$filename': $!\n";

    while (my $line = <$script_fh>) {
        chomp $line;

        # Skip empty lines and comments
        next if $line =~ /^\s*$/ || $line =~ /^\s*#/;

        # Process commands (simplified version of interactive_debug command processing)
        if ($line =~ /^\s*add-rule\s+(.+?)\s*:\s*(.+?)\s*:\s*(.+)$/i) {
            my ($target, $deps_str, $rule_text) = ($1, $2, $3);
            $target =~ s/^\s+|\s+$//g;
            $deps_str =~ s/^\s+|\s+$//g;
            $rule_text =~ s/\\n/\n/g;
            $rule_text =~ s/\\t/\t/g;
            # Ensure each line starts with a tab (Makefile requirement)
            $rule_text = join("\n", map { /^\t/ ? $_ : "\t$_" } split(/\n/, $rule_text));
            $rule_text =~ s/\$\(([^)]+)\)/\$MV{$1}/g;

            my @deps = split(/\s+/, $deps_str);
            my $key = "$makefile\t$target";
            my $type = classify_target($target);

            if ($type eq 'fixed') {
                $fixed_rule{$key} = $rule_text;
                $fixed_deps{$key} = \@deps;
            } elsif ($type eq 'pattern') {
                $pattern_rule{$key} = $rule_text;
                $pattern_deps{$key} = \@deps;
            } else {
                $pseudo_rule{$key} = $rule_text;
                $pseudo_deps{$key} = \@deps;
            }
        }
        elsif ($line =~ /^\s*mod-rule\s+(.+?)\s*:\s*(.+)$/i) {
            my ($target, $rule_text) = ($1, $2);
            $target =~ s/^\s+|\s+$//g;
            $rule_text =~ s/\\n/\n/g;
            $rule_text =~ s/\\t/\t/g;
            # Ensure each line starts with a tab (Makefile requirement)
            $rule_text = join("\n", map { /^\t/ ? $_ : "\t$_" } split(/\n/, $rule_text));
            $rule_text =~ s/\$\(([^)]+)\)/\$MV{$1}/g;

            my $key = "$makefile\t$target";

            if (exists $fixed_rule{$key}) {
                $fixed_rule{$key} = $rule_text;
            } elsif (exists $pattern_rule{$key}) {
                $pattern_rule{$key} = $rule_text;
            } elsif (exists $pseudo_rule{$key}) {
                $pseudo_rule{$key} = $rule_text;
            }
        }
        elsif ($line =~ /^\s*mod-deps\s+(.+?)\s*:\s*(.+)$/i) {
            my ($target, $deps_str) = ($1, $2);
            $target =~ s/^\s+|\s+$//g;
            $deps_str =~ s/^\s+|\s+$//g;
            my @deps = split(/\s+/, $deps_str);

            my $key = "$makefile\t$target";

            if (exists $fixed_deps{$key}) {
                $fixed_deps{$key} = \@deps;
            } elsif (exists $pattern_deps{$key}) {
                $pattern_deps{$key} = \@deps;
            } elsif (exists $pseudo_deps{$key}) {
                $pseudo_deps{$key} = \@deps;
            }
        }
        elsif ($line =~ /^\s*del-rule\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";

            delete $fixed_rule{$key};
            delete $fixed_deps{$key};
            delete $pattern_rule{$key};
            delete $pattern_deps{$key};
            delete $pseudo_rule{$key};
            delete $pseudo_deps{$key};
        }
    }

    close($script_fh);
}

sub print_debug_help {
    print "Commands:\n";
    print "  list [fixed|pattern|pseudo] - List targets (optionally by type)\n";
    print "  rule <target>               - Show rule for target\n";
    print "  deps <target>               - Show dependencies for target\n";
    print "  show <target>               - Show both rule and dependencies\n";
    print "  all                         - Show all rules and dependencies\n";
    print "  fixed                       - Show only fixed rules\n";
    print "  pattern                     - Show only pattern rules\n";
    print "  pseudo                      - Show only pseudo rules\n";
    print "  dry-run <target>            - Simulate building target\n";
    print "  make-cmp <target>           - Compare dry-run with gmake\n";
    print "  print <expr>                - Evaluate and print Perl expression\n";
    print "  eval <expr>                 - Evaluate raw Perl expression\n";
    print "  set                         - Show control variables\n";
    print "  add-rule <target> : <deps> : <rule>  - Add a new rule\n";
    print "  mod-rule <target> : <rule>  - Modify rule for target\n";
    print "  mod-deps <target> : <deps>  - Modify dependencies for target\n";
    print "  del-rule <target>           - Delete rule for target\n";
    print "  save [file]                 - Save modifications (default: <makefile>-smak)\n";
    print "  ! <command>                 - Execute shell command\n";
    print "  help                        - Show this help message\n";
    print "  quit                        - Exit debug mode\n";
}

sub interactive_debug {
    print "Interactive debug mode - parsed $makefile\n";
    print_debug_help();
    print "\n";

    my $term = Term::ReadLine->new('smak');
    my $OUT = $term->OUT || \*STDOUT;
    my $is_interactive = -t STDIN;

    while (1) {
        my $input;
        if ($is_interactive) {
            # Interactive mode - use readline with prompt
            $input = $term->readline($prompt);
            last unless defined $input;
        } else {
            # Non-interactive mode - use plain STDIN without prompt
            $input = <STDIN>;
            last unless defined $input;
        }

        chomp $input;

        # Echo command line if echo is enabled
        if ($echo && $input =~ /\S/) {
            if ($is_interactive) {
                print "$prompt$input\n";
            } else {
                print "$input\n";
            }
        }

        last if $input =~ /^\s*(quit|exit|q)\s*$/i;

        # Add non-empty input to history (interactive mode only)
        $term->addhistory($input) if $input =~ /\S/ && $is_interactive;

        if ($input =~ /^\s*list\s*$/i) {
            my @targets;
            for my $key (keys %fixed_rule, keys %fixed_deps) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            for my $key (keys %pattern_rule, keys %pattern_deps) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            for my $key (keys %pseudo_rule, keys %pseudo_deps) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            my %seen;
            @targets = grep { !$seen{$_}++ } @targets;
            print "All targets: ", join(', ', sort @targets), "\n";
        }
        elsif ($input =~ /^\s*list\s+(fixed|pattern|pseudo)\s*$/i) {
            my $type = lc($1);
            my @targets;
            my %rule_hash = $type eq 'fixed' ? %fixed_rule :
                           $type eq 'pattern' ? %pattern_rule : %pseudo_rule;
            my %deps_hash = $type eq 'fixed' ? %fixed_deps :
                           $type eq 'pattern' ? %pattern_deps : %pseudo_deps;

            for my $key (keys %rule_hash, keys %deps_hash) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            my %seen;
            @targets = grep { !$seen{$_}++ } @targets;
            print ucfirst($type) . " targets: ", join(', ', sort @targets), "\n";
        }
        elsif ($input =~ /^\s*rule\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_rule{$key}) {
                print "Rule for '$target' (fixed):\n", format_output($fixed_rule{$key});
                $found = 1;
            } elsif (exists $pattern_rule{$key}) {
                print "Rule for '$target' (pattern):\n", format_output($pattern_rule{$key});
                $found = 1;
            } elsif (exists $pseudo_rule{$key}) {
                print "Rule for '$target' (pseudo):\n", format_output($pseudo_rule{$key});
                $found = 1;
            }

            print "No rule found for target '$target'\n" unless $found;
        }
        elsif ($input =~ /^\s*deps\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_deps{$key}) {
                print "Dependencies for '$target' (fixed): ", join(', ', @{$fixed_deps{$key}}), "\n";
                $found = 1;
            } elsif (exists $pattern_deps{$key}) {
                print "Dependencies for '$target' (pattern): ", join(', ', @{$pattern_deps{$key}}), "\n";
                $found = 1;
            } elsif (exists $pseudo_deps{$key}) {
                print "Dependencies for '$target' (pseudo): ", join(', ', @{$pseudo_deps{$key}}), "\n";
                $found = 1;
            }

            print "No dependencies found for target '$target'\n" unless $found;
        }
        elsif ($input =~ /^\s*show\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_rule{$key} || exists $fixed_deps{$key}) {
                print "Target: $target (fixed)\n";
                print "Dependencies: ", join(', ', @{$fixed_deps{$key} || []}), "\n";
                print "Rule:\n", format_output($fixed_rule{$key} || "(none)\n");
                $found = 1;
            } elsif (exists $pattern_rule{$key} || exists $pattern_deps{$key}) {
                print "Target: $target (pattern)\n";
                print "Dependencies: ", join(', ', @{$pattern_deps{$key} || []}), "\n";
                print "Rule:\n", format_output($pattern_rule{$key} || "(none)\n");
                $found = 1;
            } elsif (exists $pseudo_rule{$key} || exists $pseudo_deps{$key}) {
                print "Target: $target (pseudo)\n";
                print "Dependencies: ", join(', ', @{$pseudo_deps{$key} || []}), "\n";
                print "Rule:\n", format_output($pseudo_rule{$key} || "(none)\n");
                $found = 1;
            }

            print "No information found for target '$target'\n" unless $found;
        }
        elsif ($input =~ /^\s*all\s*$/i) {
            print_rules();
        }
        elsif ($input =~ /^\s*fixed\s*$/i) {
            print_category('fixed');
        }
        elsif ($input =~ /^\s*pattern\s*$/i) {
            print_category('pattern');
        }
        elsif ($input =~ /^\s*pseudo\s*$/i) {
            print_category('pseudo');
        }
        elsif ($input =~ /^\s*help\s*$/i) {
            print_debug_help();
        }
        elsif ($input =~ /^\s*set\s*$/i) {
            print "Control Variables:\n";
            print "  \$timeout = $timeout (seconds for print/eval timeout)\n";
            print "  \$prompt = \"$prompt\" (prompt string for interactive mode)\n";
            print "  \$echo = $echo (echo command lines including prompt)\n";
        }
        elsif ($input =~ /^\s*eval\s+(.+)$/i) {
            my $expr = $1;
            # Raw Perl evaluation without transformation
            my $result = eval $expr;
            if ($@) {
                print "Error evaluating expression: $@";
            } else {
                print "$result\n" if defined $result;
            }
        }
        elsif ($input =~ /^\s*dry-run\s+(\S+)\s*$/i) {
            my $target = $1;
            print "Dry-run for target '$target':\n";
            dry_run_target($target);
        }
        elsif ($input =~ /^\s*make-cmp\s+(\S+)\s*$/i) {
            my $target = $1;
            # Capture our dry-run output
            my $our_output = '';
            {
                local *STDOUT;
                open(STDOUT, '>', \$our_output) or die "Can't redirect STDOUT: $!";
                dry_run_target($target);
            }

            # Get gmake's dry-run output
            my $gmake_output = `make -n -f $makefile $target 2>&1`;

            print "Our dry-run:\n";
            print "-" x 60 . "\n";
            print $our_output;
            print "\n";
            print "gmake -n output:\n";
            print "-" x 60 . "\n";
            print $gmake_output;
            print "\n";

            if ($our_output eq $gmake_output) {
                print "Output matches!\n";
            } else {
                print "Output differs.\n";
            }
        }
        elsif ($input =~ /^\s*!\s*(.+)$/i) {
            my $cmd = $1;
            system($cmd);
        }
        elsif ($input =~ /^\s*print\s+(.+)$/i) {
            my $expr = $1;

            # Check if this looks like a pure gmake expression (contains $(function ...))
            my $is_gmake_expr = ($expr =~ /\$\([a-z-]+\s+[^)]+\)/);

            if ($is_gmake_expr) {
                # Expand as gmake expression directly
                my $result = expand_vars($expr);
                print "$result\n";
            } else {
                # Transform $(VAR) to $MV{VAR} for Perl evaluation
                $expr =~ s/\$\(([^)]+)\)/\$MV{$1}/g;

                # Fork to evaluate with timeout
                my $pid = fork();
                if (!defined $pid) {
                    print "Error: Cannot fork: $!\n";
                    next;
                }

                if ($pid == 0) {
                    # Child process - evaluate expression
                    $| = 1;  # Flush output immediately
                    $SIG{ALRM} = sub { die "timeout\n" };
                    alarm($timeout);  # Timeout from control variable
                    my $result = eval $expr;
                    alarm(0);  # Cancel alarm
                    if ($@) {
                        if ($@ =~ /timeout/) {
                            print "Error: Expression evaluation timed out\n";
                        } else {
                            print "Error evaluating expression: $@";
                        }
                        STDOUT->flush();
                        POSIX::_exit(1);
                    }
                    # Expand nested variables in result
                    $result = expand_vars($result) if defined $result && $result =~ /\$/;
                    # Format output to show $(VAR) instead of $MV{VAR}
                    $result = format_output($result) if defined $result;
                    print "$result\n";
                    STDOUT->flush();
                    POSIX::_exit(0);
                }

            # Parent process - wait for child
            # Child has its own alarm timeout
            # Parent waits 1 second longer as backup
            my $parent_timeout = $timeout + 1;
            my $elapsed = 0;
            my $kid = 0;
            while ($elapsed < $parent_timeout) {
                $kid = waitpid($pid, WNOHANG);
                if ($kid > 0) {
                    # Child finished
                    last;
                }
                select(undef, undef, undef, 0.1);  # Sleep 100ms
                $elapsed += 0.1;
            }

            # Backup: if child somehow still running, force kill
            if ($kid == 0) {
                kill('KILL', $pid);
                waitpid($pid, 0);
                print "Error: Expression evaluation forcefully terminated\n";
            }
            }
        }
        elsif ($input =~ /^\s*add-rule\s+(.+?)\s*:\s*(.+?)\s*:\s*(.+)$/i) {
            my ($target, $deps_str, $rule_text) = ($1, $2, $3);
            $target =~ s/^\s+|\s+$//g;
            $deps_str =~ s/^\s+|\s+$//g;
            # Convert \n and \t in rule text to actual newlines and tabs
            $rule_text =~ s/\\n/\n/g;
            $rule_text =~ s/\\t/\t/g;
            # Ensure each line starts with a tab (Makefile requirement)
            $rule_text = join("\n", map { /^\t/ ? $_ : "\t$_" } split(/\n/, $rule_text));
            # Transform $(VAR) to $MV{VAR} in rule
            $rule_text =~ s/\$\(([^)]+)\)/\$MV{$1}/g;

            my @deps = split(/\s+/, $deps_str);
            my $key = "$makefile\t$target";
            my $type = classify_target($target);

            if ($type eq 'fixed') {
                $fixed_rule{$key} = $rule_text;
                $fixed_deps{$key} = \@deps;
            } elsif ($type eq 'pattern') {
                $pattern_rule{$key} = $rule_text;
                $pattern_deps{$key} = \@deps;
            } else {
                $pseudo_rule{$key} = $rule_text;
                $pseudo_deps{$key} = \@deps;
            }

            # Track modification
            my $save_text = $rule_text;
            $save_text =~ s/\n/\\n/g;
            $save_text =~ s/\t/\\t/g;
            push @modifications, "add-rule $target : $deps_str : $save_text";
            print "Added rule for '$target'\n";
        }
        elsif ($input =~ /^\s*mod-rule\s+(.+?)\s*:\s*(.+)$/i) {
            my ($target, $rule_text) = ($1, $2);
            $target =~ s/^\s+|\s+$//g;
            # Convert \n and \t in rule text to actual newlines and tabs
            $rule_text =~ s/\\n/\n/g;
            $rule_text =~ s/\\t/\t/g;
            # Ensure each line starts with a tab (Makefile requirement)
            $rule_text = join("\n", map { /^\t/ ? $_ : "\t$_" } split(/\n/, $rule_text));
            # Transform $(VAR) to $MV{VAR} in rule
            $rule_text =~ s/\$\(([^)]+)\)/\$MV{$1}/g;

            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_rule{$key}) {
                $fixed_rule{$key} = $rule_text;
                $found = 1;
            } elsif (exists $pattern_rule{$key}) {
                $pattern_rule{$key} = $rule_text;
                $found = 1;
            } elsif (exists $pseudo_rule{$key}) {
                $pseudo_rule{$key} = $rule_text;
                $found = 1;
            }

            if ($found) {
                my $save_text = $rule_text;
                $save_text =~ s/\n/\\n/g;
                $save_text =~ s/\t/\\t/g;
                push @modifications, "mod-rule $target : $save_text";
                print "Modified rule for '$target'\n";
            } else {
                print "No rule found for target '$target'\n";
            }
        }
        elsif ($input =~ /^\s*mod-deps\s+(.+?)\s*:\s*(.+)$/i) {
            my ($target, $deps_str) = ($1, $2);
            $target =~ s/^\s+|\s+$//g;
            $deps_str =~ s/^\s+|\s+$//g;
            my @deps = split(/\s+/, $deps_str);

            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_deps{$key}) {
                $fixed_deps{$key} = \@deps;
                $found = 1;
            } elsif (exists $pattern_deps{$key}) {
                $pattern_deps{$key} = \@deps;
                $found = 1;
            } elsif (exists $pseudo_deps{$key}) {
                $pseudo_deps{$key} = \@deps;
                $found = 1;
            }

            if ($found) {
                push @modifications, "mod-deps $target : $deps_str";
                print "Modified dependencies for '$target'\n";
            } else {
                print "No rule found for target '$target'\n";
            }
        }
        elsif ($input =~ /^\s*del-rule\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_rule{$key} || exists $fixed_deps{$key}) {
                delete $fixed_rule{$key};
                delete $fixed_deps{$key};
                $found = 1;
            } elsif (exists $pattern_rule{$key} || exists $pattern_deps{$key}) {
                delete $pattern_rule{$key};
                delete $pattern_deps{$key};
                $found = 1;
            } elsif (exists $pseudo_rule{$key} || exists $pseudo_deps{$key}) {
                delete $pseudo_rule{$key};
                delete $pseudo_deps{$key};
                $found = 1;
            }

            if ($found) {
                push @modifications, "del-rule $target";
                print "Deleted rule for '$target'\n";
            } else {
                print "No rule found for target '$target'\n";
            }
        }
        elsif ($input =~ /^\s*save(?:\s+(.+))?\s*$/i) {
            my $save_file = $1 || "$makefile-smak";
            $save_file =~ s/^\s+|\s+$//g if defined $save_file;

            open(my $save_fh, '>', $save_file) or do {
                print "Error: Cannot open '$save_file' for writing: $!\n";
                next;
            };

            foreach my $mod (@modifications) {
                print $save_fh "$mod\n";
            }
            close($save_fh);

            print "Saved " . scalar(@modifications) . " modification(s) to '$save_file'\n";
        }
        elsif ($input =~ /^\s*$/i) {
            # Ignore empty lines
        }
        else {
            print "Unknown command. Type 'help' for available commands.\n";
        }
    }

    print "Exiting debug mode.\n";
}

sub print_category {
    my ($type) = @_;
    my %rule_hash = $type eq 'fixed' ? %fixed_rule :
                   $type eq 'pattern' ? %pattern_rule : %pseudo_rule;
    my %deps_hash = $type eq 'fixed' ? %fixed_deps :
                   $type eq 'pattern' ? %pattern_deps : %pseudo_deps;

    print uc($type) . " RULES:\n";
    print "-" x 60 . "\n";

    my %seen;
    for my $key (sort keys %rule_hash, keys %deps_hash) {
        next if $seen{$key}++;
        print "Key: $key\n";
        print "Dependencies: ", join(', ', @{$deps_hash{$key} || []}), "\n";
        print "Rule:\n", format_output($rule_hash{$key} || "(none)\n");
        print "-" x 60 . "\n";
    }
}
