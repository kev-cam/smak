#!/usr/bin/perl
use strict;
use warnings;
use FindBin qw($RealBin);
use lib $RealBin;
use Smak;
use Cwd qw(getcwd);

# smak-debug: Diagnostic tool for analyzing Makefile parsing and execution
# Usage: smak-debug [options] [target]

my $show_vars = 0;
my $show_targets = 0;
my $show_includes = 0;
my $show_command = 0;
my $compare_make = 0;
my $target = '';
my $makefile = 'Makefile';
my $verbose = 0;

# Parse command line arguments
while (@ARGV) {
    my $arg = shift @ARGV;

    if ($arg eq '-v' || $arg eq '--vars') {
        $show_vars = 1;
    }
    elsif ($arg eq '-t' || $arg eq '--targets') {
        $show_targets = 1;
    }
    elsif ($arg eq '-i' || $arg eq '--includes') {
        $show_includes = 1;
    }
    elsif ($arg eq '-c' || $arg eq '--command') {
        $show_command = 1;
    }
    elsif ($arg eq '-m' || $arg eq '--compare') {
        $compare_make = 1;
    }
    elsif ($arg eq '-this' || $arg eq '--this') {
        # Analyze everything for the first target
        $show_vars = 1;
        $show_targets = 1;
        $show_includes = 1;
        $show_command = 1;
        $compare_make = 1;
        $verbose = 1;
    }
    elsif ($arg eq '-f' || $arg eq '--file') {
        $makefile = shift @ARGV || die "Error: -f requires an argument\n";
    }
    elsif ($arg eq '-h' || $arg eq '--help') {
        print_help();
        exit 0;
    }
    elsif ($arg !~ /^-/) {
        $target = $arg;
    }
    else {
        die "Unknown option: $arg\n";
    }
}

# Default: show everything if no options specified
unless ($show_vars || $show_targets || $show_includes || $show_command || $compare_make) {
    $show_vars = 1;
    $show_targets = 1;
}

print "=== SMAK DEBUGGER ===\n";
print "Makefile: $makefile\n";
print "Directory: " . getcwd() . "\n\n";

# Check if Makefile exists
unless (-f $makefile) {
    die "Error: Makefile not found: $makefile\n";
}

# Parse the Makefile
print "Parsing Makefile...\n";
eval {
    Smak::parse_makefile($makefile);
};
if ($@) {
    die "Error parsing Makefile: $@\n";
}
print "Done.\n\n";

# Get the parsed data
my $rules = Smak::get_rules();
my $default = Smak::get_default_target();

# Determine target to analyze
unless ($target) {
    $target = $default || 'all';
}
print "Target: $target\n\n";

# Show includes (if requested)
if ($show_includes) {
    print "=" x 70 . "\n";
    print "INCLUDE FILES PROCESSED:\n";
    print "=" x 70 . "\n";
    # This would require tracking includes during parsing
    # For now, just note this feature needs implementation
    print "Note: Include tracking not yet implemented.\n";
    print "Check for 'include' directives manually in $makefile\n\n";
}

# Show variables (if requested)
if ($show_vars) {
    print "=" x 70 . "\n";
    print "VARIABLES DEFINED:\n";
    print "=" x 70 . "\n";

    my %vars = %{$rules->{variables}};
    my @var_names = sort keys %vars;

    if (@var_names) {
        printf "Total variables: %d\n\n", scalar(@var_names);

        # Show key variables
        my @key_vars = qw(CC CXX CFLAGS CXXFLAGS CPPFLAGS LDFLAGS INCLUDES
                          CXX_FLAGS CXX_INCLUDES CXX_DEFINES CMAKE_CXX_FLAGS);

        print "Key variables:\n";
        for my $var (@key_vars) {
            if (exists $vars{$var}) {
                my $value = $vars{$var};
                # Format output nicely
                $value = Smak::format_output($value);
                print "  $var = $value\n";
            }
        }

        if ($verbose) {
            print "\nAll variables:\n";
            for my $var (@var_names) {
                my $value = $vars{$var};
                $value = Smak::format_output($value);
                # Truncate long values
                if (length($value) > 100) {
                    $value = substr($value, 0, 97) . "...";
                }
                print "  $var = $value\n";
            }
        }
    } else {
        print "No variables defined.\n";
    }
    print "\n";
}

# Show targets (if requested)
if ($show_targets) {
    print "=" x 70 . "\n";
    print "TARGETS DEFINED:\n";
    print "=" x 70 . "\n";

    my @targets;
    for my $key (keys %{$rules->{fixed_deps}}) {
        my ($file, $tgt) = split(/\t/, $key, 2);
        push @targets, $tgt if $file eq $makefile;
    }

    @targets = sort @targets;
    printf "Total targets: %d\n\n", scalar(@targets);

    if (@targets <= 20 || $verbose) {
        for my $tgt (@targets) {
            print "  $tgt\n";
        }
    } else {
        print "First 20 targets:\n";
        for my $tgt (@targets[0..19]) {
            print "  $tgt\n";
        }
        print "  ... (use -v to see all)\n";
    }
    print "\n";
}

# Show command for target (if requested)
if ($show_command) {
    print "=" x 70 . "\n";
    print "COMMAND FOR TARGET: $target\n";
    print "=" x 70 . "\n";

    my $key = "$makefile\t$target";
    my $deps = $rules->{fixed_deps}{$key};
    my $rule = $rules->{fixed_rule}{$key};

    if ($deps) {
        print "Dependencies:\n";
        for my $dep (@$deps) {
            my $expanded = Smak::format_output($dep);
            $expanded = Smak::expand_vars($expanded);
            print "  $expanded\n";
        }
        print "\n";
    }

    if ($rule && $rule =~ /\S/) {
        print "Rule (before expansion):\n";
        my $formatted = Smak::format_output($rule);
        print "  $formatted\n\n";

        print "Rule (after expansion):\n";
        my $expanded = Smak::expand_vars($formatted);

        # Expand automatic variables
        $expanded =~ s/\$@/$target/g;
        if ($deps && @$deps) {
            $expanded =~ s/\$</$deps->[0]/g;
            my $all_deps = join(' ', @$deps);
            $expanded =~ s/\$\^/$all_deps/g;
        }

        print "  $expanded\n\n";
    } else {
        print "No rule defined for this target.\n\n";
    }
}

# Compare with make (if requested)
if ($compare_make) {
    print "=" x 70 . "\n";
    print "COMPARISON WITH MAKE:\n";
    print "=" x 70 . "\n";

    print "Running: make -n -f $makefile $target\n\n";
    my $make_output = `make -n -f $makefile $target 2>&1`;

    if ($? == 0) {
        print "Make output:\n";
        print "-" x 70 . "\n";
        print $make_output;
        print "-" x 70 . "\n";
    } else {
        print "Make failed with exit code: " . ($? >> 8) . "\n";
        print $make_output;
    }
}

sub print_help {
    print <<'HELP';
smak-debug - Diagnostic tool for analyzing Makefile parsing and execution

Usage:
    smak-debug [options] [target]

Options:
    -v, --vars          Show variables defined in Makefile
    -t, --targets       Show targets defined in Makefile
    -i, --includes      Show include files processed
    -c, --command       Show expanded command for target
    -m, --compare       Compare with make's output
    -this, --this       Analyze everything (all options + verbose)
    -f, --file FILE     Use FILE instead of Makefile
    -h, --help          Show this help message

Examples:
    # Analyze current Makefile failure
    smak-debug -this

    # Show all variables
    smak-debug -v

    # Show command for specific target
    smak-debug -c mytarget

    # Compare with make
    smak-debug -m mytarget

    # Full analysis of specific target
    smak-debug -this mytarget

    # Debug specific Makefile
    smak-debug -f build.make -this mytarget

HELP
}
