#!/usr/bin/env perl
use strict;
use warnings;

# Simple Ninja â†’ Make translator.
# Handles variable assignments, rules, and build statements.

my %vars;
my %rules;
my @builds;

sub expand {
    my ($s) = @_;
    $s =~ s/\$(\w+)/$vars{$1} /ge;
    return $s;
}

my $cur_context = "";
my $cur_rule = "";
my ($in_rule, $in_build) = (0, 0);

while (<>) {
    chomp;

    # Skip empty/comment lines
    next if /^\s*$/;
    next if /^\s*#/;

    # Variable assignment
    if (/^(\w+)\s*=\s*(.*)$/) {
        $vars{$1} = expand($2);
        next;
    }

    # New rule
    if (/^rule\s+(\w+)/) {
        $cur_rule = $1;
        $rules{$cur_rule} = {};
        $in_rule = 1;
        next;
    }

    # New build statement
    if (/^build\s+(.+?):\s+(\w+)\s*(.*)$/) {
        my ($outs, $rule, $deps) = ($1, $2, $3);
        $in_rule = 0;

        my @out = split /\s+/, expand($outs);
        my @dep = split /\s+/, expand($deps);

        push @builds, {
            out  => \@out,
            rule => $rule,
            deps => \@dep,
            orderonly => [],
            implicit  => [],
            vars => {},
        };

        $in_build = 1;
        next;
    }

    # Lines inside rule:   key = value
    if ($in_rule && /^\s+(\w+)\s*=\s*(.*)$/) {
        $rules{$cur_rule}{$1} = expand($2);
        next;
    }

    # Lines inside build:   key = value
    if ($in_build && /^\s+(\w+)\s*=\s*(.*)$/) {
        my ($k, $v) = ($1, expand($2));
        $builds[-1]{vars}{$k} = $v;
        next;
    }

    # Implicit / order-only deps
    if ($in_build && /^\s*\|\s*(.*)$/) {
        push @{$builds[-1]{implicit}}, split ' ', expand($1);
        next;
    }
    if ($in_build && /^\s*\|\|\s*(.*)$/) {
        push @{$builds[-1]{orderonly}}, split ' ', expand($1);
        next;
    }
}

# --- OUTPUT ---

print "# Autogenerated Makefile from Ninja file\n\n";

# Convert each build entry into a make rule
foreach my $b (@builds) {
    my @out = @{$b->{out}};
    my $rule = $b->{rule};
    my @deps = (@{$b->{deps}}, @{$b->{implicit}});
    my @order = @{$b->{orderonly}};

    # Use only first output as target (Make limitation)
    my $target = $out[0];

    print "$target: @deps";
    print " | @order" if @order;
    print "\n";

    # Find the command for this rule
    my $cmd = $b->{vars}{command} // $rules{$rule}{command};

    if ($cmd) {
        # Ninja uses $in, $out variables
        $cmd =~ s/\$in/@{$b->{deps}}/ge;
        $cmd =~ s/\$out/@out/ge;

        print "\t$cmd\n\n";
    } else {
        print "\t# no command for rule $rule\n\n";
    }
}

# Add phony if needed
print ".PHONY: all\n";
print "all: ", join(" ", map { $_->{out}[0] } @builds), "\n";

