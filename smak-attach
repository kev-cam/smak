#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket::INET;
use IO::Select;
use Cwd 'abs_path';
use Getopt::Long;

# Parse command-line options
my $target_pid;
GetOptions('pid=i' => \$target_pid) or die "Usage: $0 [-pid <process-id>]\n";

# Find smak-jobserver processes using /proc
sub find_jobservers {
    my @jobservers;

    # Scan /proc for smak-jobserver processes
    opendir(my $proc_dir, '/proc') or die "Cannot open /proc: $!\n";
    my @pids = grep { /^\d+$/ } readdir($proc_dir);
    closedir($proc_dir);

    for my $pid (@pids) {
        my $cmdline_file = "/proc/$pid/cmdline";
        next unless -f $cmdline_file;

        open(my $fh, '<', $cmdline_file) or next;
        my $cmdline = <$fh>;
        close($fh);
        next unless $cmdline;

        $cmdline =~ s/\0/ /g;
        $cmdline =~ s/\s+$//;

        # Check if it's a smak-jobserver process
        if ($cmdline =~ /smak-jobserver\s+(\d+)/) {
            my $num_workers = $1;

            # Get working directory
            my $cwd = readlink("/proc/$pid/cwd");

            # Get listening ports using lsof
            my @ports;
            my $lsof_output = `lsof -Pan -p $pid -i TCP -s TCP:LISTEN 2>/dev/null`;
            for my $line (split /\n/, $lsof_output) {
                if ($line =~ /:(\d+)\s+\(LISTEN\)/) {
                    push @ports, $1;
                }
            }

            # Expect 3 ports: master, worker, observer
            if (@ports >= 2) {
                push @jobservers, {
                    pid => $pid,
                    workers => $num_workers,
                    cwd => $cwd,
                    ports => \@ports,
                    cmdline => $cmdline,
                };
            }
        }
    }

    return @jobservers;
}

# Verify and update port files
sub check_port_files {
    my (@jobservers) = @_;

    # Get existing port files
    my @port_files = glob("/tmp/smak-jobserver-*.port");

    # Build hash of valid PIDs
    my %valid_pids = map { $_->{pid} => 1 } @jobservers;

    # Clean up stale port files
    for my $file (@port_files) {
        my ($pid) = $file =~ /smak-jobserver-(\d+)\.port/;
        unless ($pid && $valid_pids{$pid}) {
            print STDERR "Removing stale port file: $file\n";
            unlink $file;
        }
    }

    # Verify port files are consistent
    for my $js (@jobservers) {
        my $port_file = "/tmp/smak-jobserver-$js->{pid}.port";
        if (-f $port_file) {
            # Read and verify
            open(my $fh, '<', $port_file) or next;
            my @file_ports;
            while (my $line = <$fh>) {
                chomp $line;
                push @file_ports, $line if $line =~ /^\d+$/;
            }
            close($fh);

            # Check if ports match (at least observer and master)
            if (@file_ports >= 2) {
                $js->{observer_port} = $file_ports[0];
                $js->{master_port} = $file_ports[1];
            }
        }
    }
}

# Find running job-master instances
my @jobservers = find_jobservers();

unless (@jobservers) {
    print STDERR "No running smak job-master instances found.\n";
    print STDERR "Checking for smak.pl processes...\n";

    my $smak_procs = `pgrep -lfa 'smak.pl' 2>/dev/null`;
    if ($smak_procs) {
        print STDERR "Found smak.pl processes:\n$smak_procs";
        print STDERR "\nThe job-master may have crashed. Check for errors in:\n";
        print STDERR "  - stderr output from smak.pl\n";
        print STDERR "  - Try running: SMAK_DEBUG=1 smak.pl -cli -j 4\n";
    }

    exit 1;
}

# Clean up stale port files and verify consistency
check_port_files(@jobservers);

my $selected_js;

# If -pid was specified, find that specific job-master
if ($target_pid) {
    for my $js (@jobservers) {
        if ($js->{pid} == $target_pid) {
            $selected_js = $js;
            last;
        }
    }
    unless ($selected_js) {
        die "No job-master found with PID $target_pid\n";
    }
} elsif (@jobservers > 1) {
    print "Multiple smak instances found:\n";
    for (my $i = 0; $i < @jobservers; $i++) {
        my $js = $jobservers[$i];
        print "  [$i] PID $js->{pid}";
        print " - $js->{cwd}" if $js->{cwd};
        print "\n";
        print "      Workers: $js->{workers}";
        if ($js->{master_port}) {
            print ", Master port: $js->{master_port}";
        }
        print "\n";
    }
    print "Select instance (0-" . ($#jobservers) . "): ";
    my $choice = <STDIN>;
    chomp $choice;
    if ($choice =~ /^\d+$/ && $choice <= $#jobservers) {
        $selected_js = $jobservers[$choice];
    } else {
        die "Invalid selection\n";
    }
} else {
    $selected_js = $jobservers[0];
}

my $jobserver_pid = $selected_js->{pid};
my $master_port = $selected_js->{master_port};
my $observer_port = $selected_js->{observer_port};

# Prefer master port for CLI mode, fall back to observer
my $port = $master_port || $observer_port;
unless ($port) {
    die "Cannot determine port for job-master (PID $jobserver_pid)\n";
}

print "Connecting to job-master (PID $jobserver_pid) on port $port...\n";

# Connect to master port
my $socket = IO::Socket::INET->new(
    PeerHost => '127.0.0.1',
    PeerPort => $port,
    Proto    => 'tcp',
    Timeout  => 5,
) or die "Cannot connect to job-master: $!\n";

$socket->autoflush(1);
print "Connected to job-master\n";

# Send environment variables
for my $key (keys %ENV) {
    next if $key =~ /^(BASH_FUNC_|_)/;
    my $val = $ENV{$key};
    $val =~ s/\n/ /g;
    print $socket "ENV $key=$val\n";
}
print $socket "ENV_END\n";

# Wait for ready signal
my $ready = <$socket>;
chomp $ready if defined $ready;
unless ($ready && $ready eq 'JOBSERVER_WORKERS_READY') {
    die "Job-master not ready (got: " . ($ready || "EOF") . ")\n";
}

print "Job-master ready. Entering CLI mode.\n";
print "Working directory: $selected_js->{cwd}\n" if $selected_js->{cwd};
print "Workers: $selected_js->{workers}\n\n";

# Enter CLI mode
use Term::ReadLine;
my $term = Term::ReadLine->new('smak-attach');

# Set up signal handler for graceful exit
my $exit_requested = 0;
local $SIG{INT} = sub { $exit_requested = 1; };

my $line;
while (!$exit_requested && defined($line = $term->readline('smak> '))) {
    chomp $line;
    $line =~ s/^\s+|\s+$//g;

    next if $line eq '';
    $term->addhistory($line) if $line =~ /\S/;

    my @words = split(/\s+/, $line);
    my $cmd = shift @words;

    if ($cmd eq 'quit' || $cmd eq 'exit' || $cmd eq 'q') {
        print "Shutting down job server...\n";
        print $socket "SHUTDOWN\n";
        my $ack = <$socket>;
        last;

    } elsif ($cmd eq 'detach') {
        print "Detaching from job server...\n";
        last;

    } elsif ($cmd eq 'help' || $cmd eq 'h' || $cmd eq '?') {
        print <<'HELP';
Available commands:
  build <target>      Build the specified target
  tasks, t            List pending and active tasks
  status              Show job server status
  files, f            List tracked file modifications (FUSE)
  list [pattern]      List all targets (optionally matching pattern)
  vars [pattern]      Show all variables (optionally matching pattern)
  deps <target>       Show dependencies for target
  kill                Kill all workers
  restart [N]         Restart workers (optionally specify count)
  detach              Detach from job server (leave it running)
  help, h, ?          Show this help
  quit, exit, q       Shut down job server and exit

Keyboard shortcuts:
  Ctrl-C              Detach from job server

HELP

    } elsif ($cmd eq 'build' || $cmd eq 'b') {
        if (@words == 0) {
            print "Usage: build <target>\n";
        } else {
            for my $target (@words) {
                print $socket "SUBMIT_JOB\n";
                print $socket "$target\n";
                print $socket ".\n";
                print $socket "cd . && make $target\n";

                # Wait for completion with interruptible reads
                my $select = IO::Select->new($socket);
                my $job_done = 0;
                while (!$exit_requested && !$job_done) {
                    if ($select->can_read(0.1)) {
                        my $response = <$socket>;
                        last unless defined $response;
                        chomp $response;
                        if ($response =~ /^OUTPUT (.*)$/) {
                            print "$1\n";
                        } elsif ($response =~ /^ERROR (.*)$/) {
                            print "❌ ERROR: $1\n";
                        } elsif ($response =~ /^WARN (.*)$/) {
                            print "⚠️  WARN: $1\n";
                        } elsif ($response =~ /^JOB_COMPLETE (.+?) (\d+)$/) {
                            my ($completed_target, $exit_code) = ($1, $2);
                            if ($exit_code == 0) {
                                print "✓ Build succeeded: $completed_target\n";
                            } else {
                                print "✗ Build failed: $completed_target (exit code $exit_code)\n";
                            }
                            $job_done = 1;
                        }
                    }
                }

                if ($exit_requested) {
                    print "\nBuild interrupted.\n";
                    last;
                }
            }
        }

    } elsif ($cmd eq 'tasks' || $cmd eq 't') {
        print $socket "LIST_TASKS\n";
        while (my $response = <$socket>) {
            chomp $response;
            last if $response eq 'TASKS_END';
            print "$response\n";
        }

    } elsif ($cmd eq 'status' || $cmd eq 'st') {
        print "Job server PID: $jobserver_pid\n";
        print "Workers: $selected_js->{workers}\n";
        print "Working directory: $selected_js->{cwd}\n" if $selected_js->{cwd};

    } elsif ($cmd eq 'kill') {
        print "Killing all workers...\n";
        print $socket "KILL_WORKERS\n";
        my $response = <$socket>;
        chomp $response if $response;
        print "$response\n" if $response;

    } elsif ($cmd eq 'restart') {
        my $count = @words > 0 ? $words[0] : $selected_js->{workers};
        print "Restarting workers ($count workers)...\n";
        print $socket "RESTART_WORKERS $count\n";
        my $response = <$socket>;
        chomp $response if $response;
        print "$response\n" if $response;

    } elsif ($cmd eq 'files' || $cmd eq 'f') {
        print $socket "LIST_FILES\n";
        while (my $response = <$socket>) {
            chomp $response;
            last if $response eq 'FILES_END';
            print "$response\n";
        }

    } elsif ($cmd eq 'list' || $cmd eq 'ls' || $cmd eq 'l') {
        print "list command not yet implemented in attach mode\n";

    } elsif ($cmd eq 'vars' || $cmd eq 'v') {
        print "vars command not yet implemented in attach mode\n";

    } elsif ($cmd eq 'deps' || $cmd eq 'd') {
        print "deps command not yet implemented in attach mode\n";

    } else {
        print "Unknown command: $cmd\n";
        print "Type 'help' for available commands.\n";
    }

    # Check for exit request from Ctrl-C
    if ($exit_requested) {
        last;
    }
}

if ($exit_requested || !defined($line)) {
    print "\nDetaching from job server.\n";
    print "Job server still running (PID $jobserver_pid).\n";
    print "To reattach: ./smak-attach\n";
}

close($socket);
exit 0;
