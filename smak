#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Term::ReadLine;
use POSIX ":sys_wait_h";

# Separate hashes for different rule types
my %fixed_rule;
my %fixed_deps;
my %pattern_rule;
my %pattern_deps;
my %pseudo_rule;
my %pseudo_deps;

# Hash for Makefile variables
my %MV;

# Control variables
my $timeout = 5;  # Timeout for print command evaluation in seconds

my $makefile = 'Makefile';
my $debug = 0;
my $help = 0;

# Parse command-line options
GetOptions(
    'f|file|makefile=s' => \$makefile,
    'd|debug' => \$debug,
    'h|help' => \$help,
) or die "Error in command line arguments\n";

if ($help) {
    print_help();
    exit 0;
}

sub print_help {
    print <<'HELP';
Usage: smak [options]

Options:
  -f, --file, --makefile FILE   Use FILE as a makefile (default: Makefile)
  -d, --debug                   Enter interactive debug mode
  -h, --help                    Display this help message

HELP
}

open(my $fh, '<', $makefile) or die "Cannot open $makefile: $!";

my $current_target;
my $current_rule = '';
my $current_type;  # 'fixed', 'pattern', or 'pseudo'

sub classify_target {
    my ($target) = @_;
    if ($target =~ /^\./) {
        return 'pseudo';
    } elsif ($target =~ /%/) {
        return 'pattern';
    } else {
        return 'fixed';
    }
}

sub expand_vars {
    my ($text, $depth) = @_;
    $depth ||= 0;
    return $text if $depth > 10;  # Prevent infinite recursion

    # Expand $(VAR) references
    while ($text =~ /\$\(([^)]+)\)/) {
        my $var = $1;
        my $value = $MV{$var} || "";
        $text =~ s/\$\($var\)/$value/g;
        # Recursively expand the result
        $text = expand_vars($text, $depth + 1) if $value =~ /\$/;
    }

    return $text;
}

sub format_output {
    my ($text) = @_;
    # Convert $MV{VAR} back to $(VAR) for display
    $text =~ s/\$MV\{([^}]+)\}/\$($1)/g;
    return $text;
}

sub save_current_rule {
    return unless $current_target;

    my $key = "$makefile\t$current_target";
    if ($current_type eq 'pseudo') {
        $pseudo_rule{$key} = $current_rule;
    } elsif ($current_type eq 'pattern') {
        $pattern_rule{$key} = $current_rule;
    } else {
        $fixed_rule{$key} = $current_rule;
    }
}

while (my $line = <$fh>) {
    chomp $line;

    # Skip comments and empty lines
    next if $line =~ /^\s*#/ || $line =~ /^\s*$/;

    # Check if this is a variable assignment (VAR = value, VAR := value, etc.)
    if ($line =~ /^([A-Za-z_][A-Za-z0-9_]*)\s*[:+]?=\s*(.*)$/ && $line !~ /^\t/) {
        my ($var, $value) = ($1, $2);
        $MV{$var} = $value;
        next;
    }

    # Check if this is a target line (contains : and doesn't start with tab)
    if ($line =~ /^([^:\s]+)\s*:\s*(.*)$/ && $line !~ /^\t/) {
        my $target = $1;
        my $dependencies = $2;

        # Save previous rule if exists
        save_current_rule();

        # Classify and start new target
        $current_target = $target;
        $current_type = classify_target($target);
        $current_rule = '';

        # Store dependencies in appropriate hash
        my $key = "$makefile\t$target";
        my @dep_list = grep { $_ ne '' } split(/\s+/, $dependencies);

        if ($current_type eq 'pseudo') {
            $pseudo_deps{$key} = \@dep_list;
        } elsif ($current_type eq 'pattern') {
            $pattern_deps{$key} = \@dep_list;
        } else {
            $fixed_deps{$key} = \@dep_list;
        }
    }
    # Check if this is a rule line (starts with tab)
    elsif ($line =~ /^\t(.*)$/) {
        my $command = $1;
        # Transform $(VAR) to $MV{VAR}
        $command =~ s/\$\(([^)]+)\)/\$MV{$1}/g;
        $current_rule .= $command . "\n";
    }
}

# Save last rule
save_current_rule();

close($fh);

# Debug mode or normal output
if ($debug) {
    interactive_debug();
} else {
    print_rules();
}

sub print_rules {
    print "Rules parsed from $makefile:\n";
    print "=" x 60 . "\n\n";

    # Print pseudo rules
    if (keys %pseudo_rule || keys %pseudo_deps) {
        print "PSEUDO RULES (.PHONY, .PRECIOUS, etc.):\n";
        print "-" x 60 . "\n";
        my %seen;
        for my $key (sort keys %pseudo_rule, keys %pseudo_deps) {
            next if $seen{$key}++;
            print "Key: $key\n";
            print "Dependencies: ", join(', ', @{$pseudo_deps{$key} || []}), "\n";
            print "Rule:\n", format_output($pseudo_rule{$key} || "(none)\n");
            print "-" x 60 . "\n";
        }
        print "\n";
    }

    # Print pattern rules
    if (keys %pattern_rule || keys %pattern_deps) {
        print "PATTERN RULES (with %):\n";
        print "-" x 60 . "\n";
        my %seen;
        for my $key (sort keys %pattern_rule, keys %pattern_deps) {
            next if $seen{$key}++;
            print "Key: $key\n";
            print "Dependencies: ", join(', ', @{$pattern_deps{$key} || []}), "\n";
            print "Rule:\n", format_output($pattern_rule{$key} || "(none)\n");
            print "-" x 60 . "\n";
        }
        print "\n";
    }

    # Print fixed rules
    if (keys %fixed_rule || keys %fixed_deps) {
        print "FIXED RULES:\n";
        print "-" x 60 . "\n";
        my %seen;
        for my $key (sort keys %fixed_rule, keys %fixed_deps) {
            next if $seen{$key}++;
            print "Key: $key\n";
            print "Dependencies: ", join(', ', @{$fixed_deps{$key} || []}), "\n";
            print "Rule:\n", format_output($fixed_rule{$key} || "(none)\n");
            print "-" x 60 . "\n";
        }
        print "\n";
    }
}

sub print_debug_help {
    print "Commands:\n";
    print "  list [fixed|pattern|pseudo] - List targets (optionally by type)\n";
    print "  rule <target>               - Show rule for target\n";
    print "  deps <target>               - Show dependencies for target\n";
    print "  show <target>               - Show both rule and dependencies\n";
    print "  all                         - Show all rules and dependencies\n";
    print "  fixed                       - Show only fixed rules\n";
    print "  pattern                     - Show only pattern rules\n";
    print "  pseudo                      - Show only pseudo rules\n";
    print "  print <expr>                - Evaluate and print Perl expression\n";
    print "  eval <expr>                 - Evaluate raw Perl expression\n";
    print "  set                         - Show control variables\n";
    print "  help                        - Show this help message\n";
    print "  quit                        - Exit debug mode\n";
}

sub interactive_debug {
    print "Interactive debug mode - parsed $makefile\n";
    print_debug_help();
    print "\n";

    my $term = Term::ReadLine->new('smak');
    my $prompt = "smak> ";
    my $OUT = $term->OUT || \*STDOUT;

    while (1) {
        my $input;
        if (-t STDIN) {
            # Interactive mode - use readline
            $input = $term->readline($prompt);
            last unless defined $input;
        } else {
            # Non-interactive mode - use plain STDIN
            print $OUT $prompt;
            $input = <STDIN>;
            last unless defined $input;
        }

        chomp $input;

        # Add non-empty input to history
        $term->addhistory($input) if $input =~ /\S/ && -t STDIN;

        last if $input =~ /^\s*(quit|exit|q)\s*$/i;

        if ($input =~ /^\s*list\s*$/i) {
            my @targets;
            for my $key (keys %fixed_rule, keys %fixed_deps) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            for my $key (keys %pattern_rule, keys %pattern_deps) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            for my $key (keys %pseudo_rule, keys %pseudo_deps) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            my %seen;
            @targets = grep { !$seen{$_}++ } @targets;
            print "All targets: ", join(', ', sort @targets), "\n";
        }
        elsif ($input =~ /^\s*list\s+(fixed|pattern|pseudo)\s*$/i) {
            my $type = lc($1);
            my @targets;
            my %rule_hash = $type eq 'fixed' ? %fixed_rule :
                           $type eq 'pattern' ? %pattern_rule : %pseudo_rule;
            my %deps_hash = $type eq 'fixed' ? %fixed_deps :
                           $type eq 'pattern' ? %pattern_deps : %pseudo_deps;

            for my $key (keys %rule_hash, keys %deps_hash) {
                if ($key =~ /^[^\t]+\t(.+)$/) {
                    push @targets, $1;
                }
            }
            my %seen;
            @targets = grep { !$seen{$_}++ } @targets;
            print ucfirst($type) . " targets: ", join(', ', sort @targets), "\n";
        }
        elsif ($input =~ /^\s*rule\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_rule{$key}) {
                print "Rule for '$target' (fixed):\n", format_output($fixed_rule{$key});
                $found = 1;
            } elsif (exists $pattern_rule{$key}) {
                print "Rule for '$target' (pattern):\n", format_output($pattern_rule{$key});
                $found = 1;
            } elsif (exists $pseudo_rule{$key}) {
                print "Rule for '$target' (pseudo):\n", format_output($pseudo_rule{$key});
                $found = 1;
            }

            print "No rule found for target '$target'\n" unless $found;
        }
        elsif ($input =~ /^\s*deps\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_deps{$key}) {
                print "Dependencies for '$target' (fixed): ", join(', ', @{$fixed_deps{$key}}), "\n";
                $found = 1;
            } elsif (exists $pattern_deps{$key}) {
                print "Dependencies for '$target' (pattern): ", join(', ', @{$pattern_deps{$key}}), "\n";
                $found = 1;
            } elsif (exists $pseudo_deps{$key}) {
                print "Dependencies for '$target' (pseudo): ", join(', ', @{$pseudo_deps{$key}}), "\n";
                $found = 1;
            }

            print "No dependencies found for target '$target'\n" unless $found;
        }
        elsif ($input =~ /^\s*show\s+(\S+)\s*$/i) {
            my $target = $1;
            my $key = "$makefile\t$target";
            my $found = 0;

            if (exists $fixed_rule{$key} || exists $fixed_deps{$key}) {
                print "Target: $target (fixed)\n";
                print "Dependencies: ", join(', ', @{$fixed_deps{$key} || []}), "\n";
                print "Rule:\n", format_output($fixed_rule{$key} || "(none)\n");
                $found = 1;
            } elsif (exists $pattern_rule{$key} || exists $pattern_deps{$key}) {
                print "Target: $target (pattern)\n";
                print "Dependencies: ", join(', ', @{$pattern_deps{$key} || []}), "\n";
                print "Rule:\n", format_output($pattern_rule{$key} || "(none)\n");
                $found = 1;
            } elsif (exists $pseudo_rule{$key} || exists $pseudo_deps{$key}) {
                print "Target: $target (pseudo)\n";
                print "Dependencies: ", join(', ', @{$pseudo_deps{$key} || []}), "\n";
                print "Rule:\n", format_output($pseudo_rule{$key} || "(none)\n");
                $found = 1;
            }

            print "No information found for target '$target'\n" unless $found;
        }
        elsif ($input =~ /^\s*all\s*$/i) {
            print_rules();
        }
        elsif ($input =~ /^\s*fixed\s*$/i) {
            print_category('fixed');
        }
        elsif ($input =~ /^\s*pattern\s*$/i) {
            print_category('pattern');
        }
        elsif ($input =~ /^\s*pseudo\s*$/i) {
            print_category('pseudo');
        }
        elsif ($input =~ /^\s*help\s*$/i) {
            print_debug_help();
        }
        elsif ($input =~ /^\s*set\s*$/i) {
            print "Control Variables:\n";
            print "  \$timeout = $timeout (seconds for print/eval timeout)\n";
        }
        elsif ($input =~ /^\s*eval\s+(.+)$/i) {
            my $expr = $1;
            # Raw Perl evaluation without transformation
            my $result = eval $expr;
            if ($@) {
                print "Error evaluating expression: $@";
            } else {
                print "$result\n" if defined $result;
            }
        }
        elsif ($input =~ /^\s*print\s+(.+)$/i) {
            my $expr = $1;
            # Transform $(VAR) to $MV{VAR} before evaluation
            $expr =~ s/\$\(([^)]+)\)/\$MV{$1}/g;

            # Fork to evaluate with timeout
            my $pid = fork();
            if (!defined $pid) {
                print "Error: Cannot fork: $!\n";
                next;
            }

            if ($pid == 0) {
                # Child process - evaluate expression
                $| = 1;  # Flush output immediately
                $SIG{ALRM} = sub { die "timeout\n" };
                alarm($timeout);  # Timeout from control variable
                my $result = eval $expr;
                alarm(0);  # Cancel alarm
                if ($@) {
                    if ($@ =~ /timeout/) {
                        print "Error: Expression evaluation timed out\n";
                    } else {
                        print "Error evaluating expression: $@";
                    }
                    STDOUT->flush();
                    POSIX::_exit(1);
                }
                # Expand nested variables in result
                $result = expand_vars($result) if defined $result && $result =~ /\$/;
                # Format output to show $(VAR) instead of $MV{VAR}
                $result = format_output($result) if defined $result;
                print "$result\n";
                STDOUT->flush();
                POSIX::_exit(0);
            }

            # Parent process - wait for child
            # Child has its own alarm timeout
            # Parent waits 1 second longer as backup
            my $parent_timeout = $timeout + 1;
            my $elapsed = 0;
            my $kid = 0;
            while ($elapsed < $parent_timeout) {
                $kid = waitpid($pid, WNOHANG);
                if ($kid > 0) {
                    # Child finished
                    last;
                }
                select(undef, undef, undef, 0.1);  # Sleep 100ms
                $elapsed += 0.1;
            }

            # Backup: if child somehow still running, force kill
            if ($kid == 0) {
                kill('KILL', $pid);
                waitpid($pid, 0);
                print "Error: Expression evaluation forcefully terminated\n";
            }
        }
        elsif ($input =~ /^\s*$/i) {
            # Ignore empty lines
        }
        else {
            print "Unknown command. Type 'help' for available commands.\n";
        }
    }

    print "Exiting debug mode.\n";
}

sub print_category {
    my ($type) = @_;
    my %rule_hash = $type eq 'fixed' ? %fixed_rule :
                   $type eq 'pattern' ? %pattern_rule : %pseudo_rule;
    my %deps_hash = $type eq 'fixed' ? %fixed_deps :
                   $type eq 'pattern' ? %pattern_deps : %pseudo_deps;

    print uc($type) . " RULES:\n";
    print "-" x 60 . "\n";

    my %seen;
    for my $key (sort keys %rule_hash, keys %deps_hash) {
        next if $seen{$key}++;
        print "Key: $key\n";
        print "Dependencies: ", join(', ', @{$deps_hash{$key} || []}), "\n";
        print "Rule:\n", format_output($rule_hash{$key} || "(none)\n");
        print "-" x 60 . "\n";
    }
}
