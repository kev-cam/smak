#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket::INET;
use IO::Select;
use Cwd 'abs_path';

# Get process info from /proc
sub get_process_info {
    my ($pid) = @_;
    my $info = {};

    # Get command line
    if (open(my $fh, '<', "/proc/$pid/cmdline")) {
        my $cmdline = <$fh>;
        close($fh);
        if ($cmdline) {
            # Replace null bytes with spaces
            $cmdline =~ s/\0/ /g;
            $cmdline =~ s/\s+$//;  # Trim trailing whitespace
            $info->{cmdline} = $cmdline;
        }
    }

    # Get working directory
    my $cwd_link = "/proc/$pid/cwd";
    if (-l $cwd_link) {
        my $cwd = readlink($cwd_link);
        $info->{cwd} = $cwd if $cwd;
    }

    return $info;
}

# Find running job-master instances
my @port_files = glob("/tmp/smak-jobserver-*.port");

# Filter out stale port files (process not running or not a job-master)
my @valid_files;
for my $file (@port_files) {
    my ($pid) = $file =~ /smak-jobserver-(\d+)\.port/;
    if ($pid && -d "/proc/$pid") {
        # Check if it's actually a smak-jobserver process
        my $info = get_process_info($pid);
        if ($info->{cmdline} && $info->{cmdline} =~ /smak-jobserver/) {
            push @valid_files, $file;
        } else {
            # PID exists but is not a job-master (PID reused)
            unlink $file;
        }
    } else {
        # Process not running
        unlink $file;
    }
}
@port_files = @valid_files;

unless (@port_files) {
    die "No running smak job-master instances found.\n";
}

if (@port_files > 1) {
    print "Multiple smak instances found:\n";
    for (my $i = 0; $i < @port_files; $i++) {
        my $file = $port_files[$i];
        my ($pid) = $file =~ /smak-jobserver-(\d+)\.port/;
        my $info = get_process_info($pid);

        print "  [$i] PID $pid";
        if ($info->{cwd}) {
            print " - $info->{cwd}";
        }
        print "\n";
        if ($info->{cmdline}) {
            # Extract just the job count and connection info
            my $cmd = $info->{cmdline};
            if ($cmd =~ /smak-jobserver\s+(\d+)\s+([\d.:]+)/) {
                my ($jobs, $conn) = ($1, $2);
                print "      Jobs: $jobs, Connection: $conn\n";
            }
        }
    }
    print "Select instance (0-" . ($#port_files) . "): ";
    my $choice = <STDIN>;
    chomp $choice;
    @port_files = ($port_files[$choice]) if $choice =~ /^\d+$/ && $choice <= $#port_files;
}

my $port_file = $port_files[0];
my ($jobserver_pid) = $port_file =~ /smak-jobserver-(\d+)\.port/;

# Read port number
open(my $fh, '<', $port_file) or die "Cannot read port file $port_file: $!\n";
my $port = <$fh>;
chomp $port;
close($fh);

print "Connecting to job-master (PID $jobserver_pid) on port $port...\n";

# Connect to observer socket
my $socket = IO::Socket::INET->new(
    PeerHost => '127.0.0.1',
    PeerPort => $port,
    Proto    => 'tcp',
    Timeout  => 5,
) or die "Cannot connect to job-master: $!\n";

$socket->autoflush(1);
print "Connected to job-master observer.\n";
print "Commands: [s]tatus, [q]uit, [h]elp\n\n";

# Set up select for non-blocking I/O
my $select = IO::Select->new($socket, \*STDIN);

# Request initial status
print $socket "STATUS\n";

my $in_status = 0;

while (1) {
    my @ready = $select->can_read(0.1);

    for my $handle (@ready) {
        if ($handle == $socket) {
            # Message from job-master
            my $line = <$socket>;
            unless (defined $line) {
                print "\nJob-master disconnected.\n";
                exit 0;
            }
            chomp $line;

            if ($line eq 'STATUS_START') {
                $in_status = 1;
                print "\n=== Build Status ===\n";

            } elsif ($line eq 'STATUS_END') {
                $in_status = 0;
                print "==================\n";
                print "smak-attach> ";
                STDOUT->flush();

            } elsif ($line =~ /^QUEUED (\d+)$/) {
                print "Queued jobs: $1\n";

            } elsif ($line =~ /^RUNNING (\d+)$/) {
                print "Running jobs: $1\n";

            } elsif ($line =~ /^WORKERS (\d+)$/) {
                print "Total workers: $1\n\n";

            } elsif ($line =~ /^QUEUE_ITEM (.*)$/) {
                print "  [Queued] $1\n";

            } elsif ($line =~ /^RUNNING_ITEM (\d+) (\w+) (.*)$/) {
                my ($task_id, $state, $target) = ($1, $2, $3);
                print "  [$state] Task $task_id: $target\n";

            } elsif ($line =~ /^WORKER_STATUS (\w+) (\d+)$/) {
                my ($status, $task_id) = ($1, $2);
                if ($status eq 'READY') {
                    print "  Worker: READY (idle)\n";
                } else {
                    print "  Worker: BUSY (task $task_id)\n";
                }

            } elsif ($line =~ /^QUEUED (.*)$/) {
                print "[Queued] $1\n";

            } else {
                print "$line\n" if $line;
            }

        } elsif ($handle == \*STDIN) {
            # User input
            my $input = <STDIN>;
            unless (defined $input) {
                print "\nExiting...\n";
                print $socket "QUIT\n";
                exit 0;
            }
            chomp $input;

            if ($input =~ /^s(tatus)?$/i) {
                print $socket "STATUS\n";

            } elsif ($input =~ /^q(uit)?$/i) {
                print "Disconnecting...\n";
                print $socket "QUIT\n";
                exit 0;

            } elsif ($input =~ /^h(elp)?$/i) {
                print "\nCommands:\n";
                print "  s, status - Request current build status\n";
                print "  q, quit   - Disconnect and exit\n";
                print "  h, help   - Show this help\n\n";

            } elsif ($input ne '') {
                print "Unknown command. Type 'h' for help.\n";
            }
        }
    }
}
