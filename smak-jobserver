#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket::INET;
use IO::Select;
use POSIX qw(:sys_wait_h);
use FindBin qw($RealBin);

# Job-master server that manages worker pool
# Sits in select() loop listening to:
#   - Master socket (build requests)
#   - Worker sockets (job results)

# Usage: smak-jobserver <num_workers> <master_host:port>
my ($num_workers, $master_addr) = @ARGV;
die "Usage: $0 <num_workers> <master_host:port>\n" unless $num_workers && $master_addr;

# Parse master address
my ($master_host, $master_port) = split(/:/, $master_addr);
die "Invalid master address. Use host:port\n" unless defined $master_port;

# Connect to master
print STDERR "Job-master connecting to master at $master_host:$master_port...\n";
my $master_socket = IO::Socket::INET->new(
    PeerHost => $master_host,
    PeerPort => $master_port,
    Proto    => 'tcp',
    Timeout  => 10,
) or die "Cannot connect to master: $!\n";

$master_socket->autoflush(1);
print STDERR "Job-master connected to master\n";

# Send ready signal
print $master_socket "JOBSERVER_READY\n";

# Receive environment from master
my %worker_env;
while (my $line = <$master_socket>) {
    chomp $line;
    last if $line eq 'ENV_END';
    if ($line =~ /^ENV (\w+)=(.*)$/) {
        $worker_env{$1} = $2;
    }
}
print STDERR "Job-master received environment\n";

# Create worker pool
my @workers;
my %worker_status;  # socket => {busy => 0/1, task_id => N}
my $worker_script = "$RealBin/smak-worker";
die "Worker script not found: $worker_script\n" unless -x $worker_script;

# Create socket server for workers
my $worker_server = IO::Socket::INET->new(
    LocalAddr => '127.0.0.1',
    LocalPort => 0,  # Let OS assign port
    Proto     => 'tcp',
    Listen    => $num_workers,
    Reuse     => 1,
) or die "Cannot create worker server: $!\n";

my $worker_port = $worker_server->sockport();
print STDERR "Job-master worker server on port $worker_port\n";

# Create socket server for observers (monitoring/attach)
my $observer_server = IO::Socket::INET->new(
    LocalAddr => '127.0.0.1',
    LocalPort => 0,  # Let OS assign port
    Proto     => 'tcp',
    Listen    => 5,  # Allow multiple observers
    Reuse     => 1,
) or die "Cannot create observer server: $!\n";

my $observer_port = $observer_server->sockport();
print STDERR "Job-master observer server on port $observer_port\n";

# Write observer port to file for smak-attach to find
open(my $port_fh, '>', "/tmp/smak-jobserver-$$.port") or warn "Cannot write port file: $!\n";
if ($port_fh) {
    print $port_fh "$observer_port\n";
    close($port_fh);
}

my @observers;  # List of connected observers

# Spawn workers
for (my $i = 0; $i < $num_workers; $i++) {
    my $pid = fork();
    die "Cannot fork worker: $!\n" unless defined $pid;

    if ($pid == 0) {
        # Child - exec worker
        exec($worker_script, "127.0.0.1:$worker_port");
        die "Failed to exec worker: $!\n";
    }
    print STDERR "Spawned worker $i (PID $pid)\n";
}

# Accept worker connections
$worker_server->blocking(0);
$observer_server->blocking(0);
my $select = IO::Select->new($worker_server, $observer_server, $master_socket);
my $workers_connected = 0;
my $startup_timeout = 10;
my $start_time = time();

while ($workers_connected < $num_workers) {
    if (time() - $start_time > $startup_timeout) {
        die "Timeout waiting for workers\n";
    }

    my @ready = $select->can_read(0.1);
    for my $socket (@ready) {
        if ($socket == $worker_server) {
            my $worker = $worker_server->accept();
            if ($worker) {
                $worker->autoflush(1);

                # Wait for READY
                my $ready = <$worker>;
                chomp $ready if defined $ready;
                if ($ready eq 'READY') {
                    push @workers, $worker;
                    $worker_status{$worker} = {ready => 1, task_id => 0};
                    $select->add($worker);
                    $workers_connected++;
                    print STDERR "Worker connected ($workers_connected/$num_workers)\n";

                    # Send environment
                    print $worker "ENV_START\n";
                    for my $key (keys %worker_env) {
                        print $worker "ENV $key=$worker_env{$key}\n";
                    }
                    print $worker "ENV_END\n";
                }
            }
        }
    }
}

print STDERR "All workers ready. Job-master entering listen loop.\n";
print $master_socket "JOBSERVER_WORKERS_READY\n";

# Job queue
my @job_queue;
my %running_jobs;  # task_id => {target, worker, dir, command}
my $next_task_id = 1;

# Main event loop
while (1) {
    my @ready = $select->can_read(0.1);

    for my $socket (@ready) {
        if ($socket == $master_socket) {
            # Master sent us something
            my $line = <$socket>;
            unless (defined $line) {
                print STDERR "Master disconnected. Shutting down.\n";
                shutdown_workers();
                exit 0;
            }
            chomp $line;

            if ($line eq 'SHUTDOWN') {
                print STDERR "Shutdown requested by master.\n";
                shutdown_workers();
                print $master_socket "SHUTDOWN_ACK\n";
                exit 0;

            } elsif ($line =~ /^SUBMIT_JOB$/) {
                # Read job details
                my $target = <$socket>; chomp $target if defined $target;
                my $dir = <$socket>; chomp $dir if defined $dir;
                my $cmd = <$socket>; chomp $cmd if defined $cmd;

                # Queue the job
                push @job_queue, {
                    target => $target,
                    dir => $dir,
                    command => $cmd,
                };

                print STDERR "Queued job: $target\n";
                broadcast_observers("QUEUED $target");

                # Try to dispatch
                dispatch_jobs();

            } elsif ($line =~ /^LIST_TASKS$/) {
                # Send task list to master
                print $master_socket "Queued tasks: " . scalar(@job_queue) . "\n";
                for my $job (@job_queue) {
                    print $master_socket "  [QUEUED] $job->{target}\n";
                }
                print $master_socket "Running tasks: " . scalar(keys %running_jobs) . "\n";
                for my $task_id (sort { $a <=> $b } keys %running_jobs) {
                    my $job = $running_jobs{$task_id};
                    my $state = $job->{started} ? 'RUNNING' : 'DISPATCHED';
                    print $master_socket "  [$state] Task $task_id: $job->{target}\n";
                }
                print $master_socket "TASKS_END\n";

            } elsif ($line =~ /^KILL_WORKERS$/) {
                # Kill all workers
                print STDERR "Killing all workers\n";
                for my $worker (@workers) {
                    print $worker "SHUTDOWN\n";
                    close($worker);
                    $select->remove($worker);
                }
                @workers = ();
                %worker_status = ();
                %running_jobs = ();
                print $master_socket "All workers killed\n";

            } elsif ($line =~ /^RESTART_WORKERS (\d+)$/) {
                my $new_count = $1;
                # Kill existing workers
                print STDERR "Restarting workers ($new_count)\n";
                for my $worker (@workers) {
                    print $worker "SHUTDOWN\n";
                    close($worker);
                    $select->remove($worker);
                }
                @workers = ();
                %worker_status = ();
                %running_jobs = ();

                # Spawn new workers
                my $worker_port = $worker_server->sockport();
                for (my $i = 0; $i < $new_count; $i++) {
                    my $worker_pid = fork();
                    if ($worker_pid == 0) {
                        exec($worker_script, "127.0.0.1:$worker_port");
                        die "Failed to exec worker: $!\n";
                    }
                }
                print $master_socket "Restarting $new_count workers...\n";
            }

        } elsif ($socket == $worker_server) {
            # New worker connecting
            my $worker = $worker_server->accept();
            if ($worker) {
                $worker->autoflush(1);
                $select->add($worker);
                push @workers, $worker;
                $worker_status{$worker} = {ready => 0, task_id => 0};
                print STDERR "Worker connected during runtime\n";
            }

        } elsif ($socket == $observer_server) {
            # New observer connecting
            my $observer = $observer_server->accept();
            if ($observer) {
                $observer->autoflush(1);
                $select->add($observer);
                push @observers, $observer;
                print STDERR "Observer connected\n";
                # Send current status
                send_status($observer);
            }

        } elsif (grep { $_ == $socket } @observers) {
            # Observer sent command
            my $line = <$socket>;
            unless (defined $line) {
                # Observer disconnected
                print STDERR "Observer disconnected\n";
                $select->remove($socket);
                @observers = grep { $_ != $socket } @observers;
                next;
            }
            chomp $line;

            if ($line eq 'STATUS') {
                send_status($socket);
            } elsif ($line eq 'QUIT') {
                close($socket);
                $select->remove($socket);
                @observers = grep { $_ != $socket } @observers;
            }

        } else {
            # Worker sent us something
            my $line = <$socket>;
            unless (defined $line) {
                # Worker disconnected
                print STDERR "Worker disconnected\n";
                $select->remove($socket);
                next;
            }
            chomp $line;

            if ($line eq 'READY') {
                # Worker is ready for a job
                $worker_status{$socket}{ready} = 1;
                print STDERR "Worker ready\n";
                # Try to dispatch queued jobs
                dispatch_jobs();

            } elsif ($line =~ /^TASK_START (\d+)$/) {
                my $task_id = $1;
                # Mark task as actually running (not just dispatched)
                if (exists $running_jobs{$task_id}) {
                    $running_jobs{$task_id}{started} = 1;
                }
                print STDERR "Task $task_id started\n";

            } elsif ($line =~ /^OUTPUT (.*)$/) {
                my $output = $1;
                # Forward to master
                print $master_socket "OUTPUT $output\n";

            } elsif ($line =~ /^TASK_END (\d+) (\d+)$/) {
                my ($task_id, $exit_code) = ($1, $2);
                my $job = $running_jobs{$task_id};

                # Don't mark ready here - wait for READY message
                delete $running_jobs{$task_id};

                print STDERR "Task $task_id completed (exit=$exit_code)\n";

                # Report to master
                print $master_socket "JOB_COMPLETE $job->{target} $exit_code\n";
            }
        }
    }
}

sub dispatch_jobs {
    while (@job_queue) {
        # Find ready worker
        my $ready_worker;
        for my $worker (@workers) {
            if ($worker_status{$worker}{ready}) {
                $ready_worker = $worker;
                last;
            }
        }

        last unless $ready_worker;  # No ready workers

        # Dispatch job
        my $job = shift @job_queue;
        my $task_id = $next_task_id++;

        # Mark worker as no longer ready (will send READY when done)
        $worker_status{$ready_worker}{ready} = 0;
        $worker_status{$ready_worker}{task_id} = $task_id;
        $running_jobs{$task_id} = $job;
        $running_jobs{$task_id}{worker} = $ready_worker;

        print $ready_worker "TASK $task_id\n";
        print $ready_worker "DIR $job->{dir}\n";
        print $ready_worker "CMD $job->{command}\n";

        print STDERR "Dispatched task $task_id to worker\n";
    }
}

sub shutdown_workers {
    for my $worker (@workers) {
        print $worker "SHUTDOWN\n";
        close($worker);
    }

    # Reap worker processes
    while ((my $pid = waitpid(-1, WNOHANG)) > 0) {
        # Zombie reaper
    }
}

sub broadcast_observers {
    my ($message) = @_;
    for my $observer (@observers) {
        print $observer "$message\n";
    }
}

sub send_status {
    my ($observer) = @_;

    # Send queue status
    print $observer "STATUS_START\n";
    print $observer "QUEUED " . scalar(@job_queue) . "\n";
    print $observer "RUNNING " . scalar(keys %running_jobs) . "\n";
    print $observer "WORKERS " . scalar(@workers) . "\n";

    # Send queued jobs
    for my $job (@job_queue) {
        print $observer "QUEUE_ITEM $job->{target}\n";
    }

    # Send running jobs
    for my $task_id (sort { $a <=> $b } keys %running_jobs) {
        my $job = $running_jobs{$task_id};
        my $state = $job->{started} ? 'RUNNING' : 'DISPATCHED';
        print $observer "RUNNING_ITEM $task_id $state $job->{target}\n";
    }

    # Send worker status
    for my $worker (@workers) {
        my $status = $worker_status{$worker};
        my $ready = $status->{ready} ? 'READY' : 'BUSY';
        my $task_id = $status->{task_id} || 0;
        print $observer "WORKER_STATUS $ready $task_id\n";
    }

    print $observer "STATUS_END\n";
}
