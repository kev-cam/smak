#!/bin/bash
# Test a specific git revision
# Usage: ./test-revision [options] [commit-hash]
#        If no hash provided, shows menu to select from recent commits

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$REPO_ROOT"

# Default options
NUM_COMMITS=9999
RUN_TESTS=1

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -n|--num)
            NUM_COMMITS="$2"
            shift 2
            ;;
        -notest|--no-test)
            RUN_TESTS=0
            shift
            ;;
        -h|--help)
            cat << 'EOF'
Usage: ./test-revision [options] [commit-hash]

Test a specific git revision in a clean cloned environment.

Options:
  -n, --num <number>    Number of commits to show in log (default: 9999 = all)
  -notest, --no-test    Skip running regression tests (just clone and shell)
  -h, --help            Show this help

If no commit hash is provided, shows all commits with date/time and prompts for selection.

Examples:
  ./test-revision                    # Interactive selection from all commits
  ./test-revision -n 50              # Show last 50 commits for selection
  ./test-revision abc123             # Test specific commit
  ./test-revision -notest abc123     # Clone commit, drop to shell, skip tests
EOF
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            echo "Run '$0 --help' for usage"
            exit 1
            ;;
        *)
            # Not an option, must be commit hash
            COMMIT="$1"
            shift
            ;;
    esac
done

# If a commit hash is provided, use it
if [ -z "$COMMIT" ]; then
    # Show recent commits and let user pick
    echo "Recent commits on current branch:"
    echo "=================================="
    git log --format='%h %ad %s' --date=format:'%Y-%m-%d %H:%M' -${NUM_COMMITS}
    echo ""
    echo -n "Enter commit hash (or press Enter for HEAD): "
    read COMMIT

    if [ -z "$COMMIT" ]; then
        COMMIT="HEAD"
    fi
fi

# Validate commit exists
if ! git rev-parse "$COMMIT" >/dev/null 2>&1; then
    echo "Error: Invalid commit '$COMMIT'"
    exit 1
fi

# Get commit short hash for directory name
COMMIT_SHORT=$(git rev-parse --short "$COMMIT")
TAG=$(date +%Y%m%d-%H%M%S)
TEST_DIR="/tmp/smak/test-${TAG}-${COMMIT_SHORT}"

echo ""
echo "Testing commit: $(git log -1 --oneline "$COMMIT")"
echo "Test directory: $TEST_DIR"
echo ""

# Create test directory and clone
echo "Cloning repository to test directory..."
mkdir -p "$TEST_DIR"
git clone -q "$REPO_ROOT" "$TEST_DIR"

# Checkout the target commit in the cloned directory
echo "Checking out $COMMIT in clone..."
cd "$TEST_DIR"
git checkout -q "$COMMIT"

# Run tests if requested
if [ $RUN_TESTS -eq 1 ]; then
    echo ""
    echo "Running regression tests..."
    echo "============================"
    cd test
    if ./run-regression; then
        TEST_RESULT="PASSED"
        TEST_EXIT=0
    else
        TEST_RESULT="FAILED"
        TEST_EXIT=1
    fi

    # Print summary
    echo ""
    echo "============================"
    echo "Test Summary"
    echo "============================"
    echo "Commit:  $(git log -1 --oneline "$COMMIT")"
    echo "Result:  $TEST_RESULT"
    echo ""
    echo "Test directory: $TEST_DIR"
    echo "============================"
    echo ""
else
    echo ""
    echo "============================"
    echo "Skipping tests (use without -notest to run tests)"
    echo "============================"
    echo "Commit:  $(git log -1 --oneline "$COMMIT")"
    echo "Test directory: $TEST_DIR"
    echo "============================"
    echo ""
    TEST_RESULT="SKIPPED"
    TEST_EXIT=0
    cd "$TEST_DIR"
fi

# Drop into shell with smak in PATH
echo "Dropping into shell with smak directory in PATH"
echo "smak command will run from: $TEST_DIR"
echo "Type 'exit' to return and cleanup"
echo ""

# Add smak directory to PATH and start interactive shell
cd "$TEST_DIR"
export PATH="$TEST_DIR:$PATH"
export PS1="[smak-test-${COMMIT_SHORT}] \w\$ "

# Start bash in interactive mode
bash --norc --noprofile -i

# After shell exits, prompt for cleanup
echo ""
echo -n "Remove test directory $TEST_DIR? (y/N): "
read -r cleanup

if [ "$cleanup" = "y" ] || [ "$cleanup" = "Y" ]; then
    echo "Removing $TEST_DIR..."
    rm -rf "$TEST_DIR"
    echo "Cleanup complete."
else
    echo "Test directory preserved at: $TEST_DIR"
fi

echo ""
exit $TEST_EXIT
