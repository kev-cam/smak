#!/usr/bin/perl
# smak-ninja: convert build.ninja -> Makefile with fully expanded commands
# Usage: ./smak-ninja build.ninja > Makefile

use warnings;

my $ninja_file = shift or die "Usage: $0 build.ninja\n";

open my $fh, '<', $ninja_file or die "Cannot open $ninja_file: $!\n";

my %rules;      # rule_name -> { command => ..., vars => { ... } }
my %builds;     # build_target -> { rule => ..., inputs => [], vars => { ... } }
my %vars;       # global variables

my $current_rule;
my $current_build;
my $in_build = 0;
my $in_rule = 0;

while (<$fh>) {
    chomp;
    s/\s+$//;  # remove trailing spaces

    next if /^#/;   # skip comments
    next if /^\s*$/;

    # variable assignment: var = value
    if (/^(\S+)\s*=\s*(.*)$/) {
        my ($var, $val) = ($1, $2);
        $vars{$var} = $val;
        next;
    }

    # rule start: rule name
    if (/^rule\s+(\S+)/) {
        $current_rule = $1;
        $rules{$current_rule} = { command => '', vars => {} };
        $in_rule = 1;
        next;
    }

    if ($in_rule) {
        # command line inside rule
        if (/^\s+command\s*=\s*(.*)$/) {
            $rules{$current_rule}{command} = $1;
            next;
        }
        # variables inside rule
        if (/^\s+(\S+)\s*=\s*(.*)$/) {
            $rules{$current_rule}{vars}{$1} = $2;
            next;
        }
        $in_rule = 0;  # end of rule block
    }

    # build line
    if (/^build\s+(\S+)\s*:\s*(\S+)\s*(.*)$/) {
        my ($out, $rule, $ins) = ($1, $2, $3);
        $builds{$out} = {
            rule => $rule,
            inputs => [ split(/\s+/, $ins) ],
            vars => {}
        };
        $current_build = $out;
        $in_build = 1;
        next;
    }

    if ($in_build) {
        if (/^\s+(\S+)\s*=\s*(.*)$/) {
            $builds{$current_build}{vars}{$1} = $2;
            next;
        }
        $in_build = 0;
    }
}

close $fh;

# recursively expand variables
sub expand {
    my ($val, $local_vars) = @_;
    $local_vars ||= {};

    while ($val =~ /\$(\w+)/) {
        my $v = $1;
        my $replacement;
        if (exists $local_vars->{$v}) {
            $replacement = $local_vars->{$v};
        } elsif (exists $vars{$v}) {
            $replacement = $vars{$v};
        } else {
            $replacement = '';
        }
        $val =~ s/\$$v/$replacement/g;
    }
    return $val;
}

print "# Auto-generated Makefile from build.ninja\n";
print "# WARNING: All commands fully expanded per target\n\n";

# write Makefile targets
for my $out (sort keys %builds) {
    my $rule = $builds{$out}{rule};
    my $inputs = $builds{$out}{inputs};
    my $local_vars = $builds{$out}{vars};

    # expand inputs
    my @deps = map { expand($_, $local_vars) } @$inputs;

    print "$out: @deps\n";

    my $cmd = $rules{$rule}{command};
    my %cmd_vars = %{ $rules{$rule}{vars} };

    # merge rule vars and build vars
    my %all_vars = (%cmd_vars, %$local_vars);

    # expand variables recursively
    for my $var (keys %all_vars) {
        $all_vars{$var} = expand($all_vars{$var}, \%all_vars);
    }

    # final command expansion
    $cmd =~ s/\$out/\$@/g;
    $cmd =~ s/\$in/\$</g;
    $cmd = expand($cmd, \%all_vars);

    print "\t$cmd\n\n";
}
