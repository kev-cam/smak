#!/bin/bash
# Test generator for smak
# Creates test-<number> directories with Makefiles for build testing

set -e

# Default values
test_num=""
num_sources=5
num_objects=10
num_targets=3
cleanup=false
run_test=false
parallel_jobs="2,4,8"  # Comma-separated list of job counts to test
build_timeout=60
max_dummy_delay=2  # Maximum delay in dummy-command (seconds)
log_timeout_multiplier=3  # Log must update within max_delay * multiplier

# Usage message
usage() {
    cat << EOF
Usage: $0 [options]

Options:
    -n NUM          Test number (default: auto-detect next available)
    -s NUM          Number of source files to generate (default: 5)
    -o NUM          Number of object/intermediate files (default: 10)
    -t NUM          Number of final targets (default: 3)
    -r              Run test after generation (sequential then parallel)
    -j NUMS         Comma-separated job counts for parallel tests (default: 2,4,8)
    -T NUM          Build timeout in seconds (default: 60)
    -c              Clean up existing test directories
    -h              Show this help

Examples:
    $0                          # Create test-1 (or next available) with defaults
    $0 -n 5 -s 10 -o 20 -t 5    # Create test-5 with custom counts
    $0 -r -j 2,4,8,16           # Create and run with multiple parallel job counts
    $0 -c                       # Clean all test-* directories
EOF
    exit 1
}

# Parse arguments
while getopts "n:s:o:t:rj:T:ch" opt; do
    case $opt in
        n) test_num=$OPTARG ;;
        s) num_sources=$OPTARG ;;
        o) num_objects=$OPTARG ;;
        t) num_targets=$OPTARG ;;
        r) run_test=true ;;
        j) parallel_jobs=$OPTARG ;;
        T) build_timeout=$OPTARG ;;
        c) cleanup=true ;;
        h) usage ;;
        *) usage ;;
    esac
done

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SMAK_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$SCRIPT_DIR"

# Cleanup mode
if $cleanup; then
    echo "Cleaning up test-* directories..."
    rm -rf test-[0-9]*
    echo "Cleanup complete"
    exit 0
fi

# Auto-detect next test number if not specified
if [[ -z "$test_num" ]]; then
    test_num=1
    while [[ -d "test-$test_num" ]]; do
        ((test_num++))
    done
fi

test_dir="test-$test_num"

echo "Generating $test_dir with:"
echo "  - $num_sources source files"
echo "  - $num_objects object files"
echo "  - $num_targets final targets"

# Create test directory
mkdir -p "$test_dir"
cd "$test_dir"

# Generate the Makefile header
cat > Makefile << 'EOF'
# Auto-generated Makefile for smak testing
# Uses dummy-command to simulate build processes

DUMMY := ../dummy-command

EOF

# Add all variable definitions first
echo "# Source files" >> Makefile
for i in $(seq 1 $num_sources); do
    echo "SOURCES += src$i.txt" >> Makefile
done


# Add object variable definitions
echo "" >> Makefile
echo "# Object/intermediate files" >> Makefile
for i in $(seq 1 $num_objects); do
    echo "OBJECTS += obj$i.o" >> Makefile
done
# Add target variable definitions
echo "" >> Makefile
echo "# Final targets" >> Makefile
for i in $(seq 1 $num_targets); do
    echo "TARGETS += target$i" >> Makefile
done

# Now add the phony targets and main rules
cat >> Makefile << 'EOF'

# Phony targets
.PHONY: all clean starters

all: $(TARGETS)

# Create starter source files
starters: $(SOURCES)

EOF

# Add source file rules
echo "# Source file rules" >> Makefile
for i in $(seq 1 $num_sources); do
    cat >> Makefile << EOF
src$i.txt:
	@echo "Creating starter file: \$@"
	@echo "Source $i" > \$@

EOF
done

# Add object file rules (depend on sources)
echo "# Object file rules" >> Makefile
# Create dependency chains - objects depend on 1-3 sources
for i in $(seq 1 $num_objects); do
    # Pick 1-3 random sources for this object
    num_deps=$((1 + RANDOM % 3))
    deps=""
    for j in $(seq 1 $num_deps); do
        src_idx=$((1 + RANDOM % num_sources))
        deps="$deps src$src_idx.txt"
    done

    cat >> Makefile << EOF
obj$i.o: $deps
	\$(DUMMY) -in $deps -out \$@

EOF
done

# Add target rules (depend on objects)
echo "# Final target rules" >> Makefile
# Create targets that depend on multiple objects
for i in $(seq 1 $num_targets); do
    # Each target depends on 2-5 objects
    num_deps=$((2 + RANDOM % 4))
    if [ $num_deps -gt $num_objects ]; then
        num_deps=$num_objects
    fi

    deps=""
    for j in $(seq 1 $num_deps); do
        obj_idx=$((1 + RANDOM % num_objects))
        deps="$deps obj$obj_idx.o"
    done

    cat >> Makefile << EOF
target$i: $deps
	\$(DUMMY) -in $deps -out \$@

EOF
done

# Add clean rule
cat >> Makefile << 'EOF'
# Clean up generated files
clean:
	rm -f $(SOURCES) $(OBJECTS) $(TARGETS)
	@echo "Cleaned all generated files"
EOF

echo ""
echo "Created $test_dir/Makefile"

# Function to monitor log file and detect hangs
monitor_log_file() {
    local log_file="$1"
    local max_idle=$((max_dummy_delay * log_timeout_multiplier))

    while true; do
        if [ ! -f "$log_file" ]; then
            sleep 0.5
            continue
        fi

        local current_time=$(date +%s)
        local file_mtime=$(stat -c %Y "$log_file" 2>/dev/null || stat -f %m "$log_file" 2>/dev/null)
        local idle_time=$((current_time - file_mtime))

        if [ $idle_time -gt $max_idle ]; then
            echo "ERROR: Log file not updated for ${idle_time}s (max idle: ${max_idle}s)"
            return 1
        fi

        sleep 1
    done
}

# Function to run build with timeout and verification
run_build() {
    local mode="$1"
    local smak_args="$2"
    local log_file="$3"
    local expected_count=$((num_sources + num_objects + num_targets))

    echo ""
    echo "========================================="
    echo "Running $mode build..."
    echo "Command: SMAK_DEBUG=1 $SMAK_DIR/smak -C $test_dir $smak_args all"
    echo "Log file: $log_file"
    echo "========================================="

    # Clean before running
    cd "$SCRIPT_DIR"
    "$SMAK_DIR/smak" -C "$test_dir" clean >/dev/null 2>&1 || true

    # Ensure log directory exists and remove old log file
    mkdir -p "$(dirname "$log_file")"
    rm -f "$log_file"

    # Start log monitor in background
    monitor_log_file "$log_file" &
    local monitor_pid=$!

    # Run build with output to both console and log file
    local build_exit_code=0
    if SMAK_DEBUG=1 timeout "$build_timeout" "$SMAK_DIR/smak" -C "$test_dir" $smak_args all 2>&1 | tee "$log_file"; then
        echo ""
        echo "Build completed successfully"
    else
        build_exit_code=$?
        kill $monitor_pid 2>/dev/null || true
        wait $monitor_pid 2>/dev/null || true

        if [ $build_exit_code -eq 124 ]; then
            echo ""
            echo "ERROR: Build timed out after ${build_timeout}s (hard timeout)"
            return 1
        else
            echo ""
            echo "ERROR: Build failed with exit code $build_exit_code"
            return 1
        fi
    fi

    # Stop log monitor
    kill $monitor_pid 2>/dev/null || true
    wait $monitor_pid 2>/dev/null || true

    # Verify that at least the targets were generated
    echo ""
    echo "Verifying targets were generated..."
    local missing_targets=0
    for i in $(seq 1 $num_targets); do
        if [ ! -f "$test_dir/target$i" ]; then
            echo "✗ ERROR: Target file target$i not found"
            ((missing_targets++))
        fi
    done

    if [ $missing_targets -eq 0 ]; then
        local file_count=$(find "$test_dir" -type f ! -name "Makefile" ! -name "*.log" | wc -l)
        echo "✓ All $num_targets targets generated successfully"
        echo "  Total files created: $file_count (including dependencies)"
        return 0
    else
        echo "✗ ERROR: $missing_targets target(s) missing"
        echo "Generated files:"
        find "$test_dir" -type f ! -name "Makefile" ! -name "*.log" | sort
        return 1
    fi
}

# Run tests if requested
if $run_test; then
    echo ""
    echo "========================================="
    echo "TESTING BUILD"
    echo "Max dummy-command delay: ${max_dummy_delay}s"
    echo "Log timeout threshold: $((max_dummy_delay * log_timeout_multiplier))s"
    echo "========================================="

    # Create logs directory in test directory
    mkdir -p "$test_dir/logs"

    # Sequential build
    log_file="$test_dir/logs/build-sequential.log"
    if ! run_build "SEQUENTIAL" "" "$log_file"; then
        echo ""
        echo "FAILED: Sequential build failed"
        echo "See log: $log_file"
        exit 1
    fi

    # Parse parallel job counts and run each
    IFS=',' read -ra JOBS <<< "$parallel_jobs"
    for jobs in "${JOBS[@]}"; do
        jobs=$(echo "$jobs" | xargs)  # Trim whitespace
        log_file="$test_dir/logs/build-parallel-j${jobs}.log"

        if ! run_build "PARALLEL (-j${jobs})" "-j${jobs}" "$log_file"; then
            echo ""
            echo "FAILED: Parallel build with -j${jobs} failed"
            echo "See log: $log_file"
            exit 1
        fi
    done

    echo ""
    echo "========================================="
    echo "✓ ALL TESTS PASSED"
    echo "========================================="
    echo "Builds completed successfully:"
    echo "  - Sequential"
    for jobs in "${JOBS[@]}"; do
        jobs=$(echo "$jobs" | xargs)
        echo "  - Parallel -j${jobs}"
    done
    echo ""
    echo "Logs saved in: $test_dir/logs/"
    ls -lh "$test_dir/logs/"
else
    echo ""
    echo "To use:"
    echo "  cd $test_dir"
    echo "  ../../smak all          # Build all targets"
    echo "  ../../smak starters     # Create only source files"
    echo "  ../../smak clean        # Clean up"
    echo ""
    echo "To test parallel builds:"
    echo "  ../../smak -j4 all      # Build with 4 parallel jobs"
    echo ""
    echo "Or run: $0 -n $test_num -r    # Re-run tests on this directory"
fi
