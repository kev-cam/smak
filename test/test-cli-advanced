#!/usr/bin/env perl
# Advanced CLI testing for smak: tests builds, caching, file changes, Ctrl-C
use strict;
use warnings;
use IPC::Open3;
use IO::Select;
use Symbol 'gensym';
use POSIX ":sys_wait_h";
use File::Path qw(remove_tree make_path);
use Cwd 'abs_path';
use File::Basename;
use Time::HiRes qw(sleep time);

# Get the directory where this script lives and add it to PATH
my $SCRIPT_DIR = dirname(abs_path($0));
$ENV{PATH} = "$SCRIPT_DIR:$ENV{PATH}";

# Configuration - use /tmp to avoid accidental deletion of test files
my $VERBOSE = $ENV{TEST_VERBOSE} || 0;
my $TEST_DIR = "/tmp/smak-test-cli-$$";
my $CACHE_DIR = "$TEST_DIR/.cache";
my $SMAK = "$SCRIPT_DIR/../smak";
my $TEST_GEN = "test-generator";
my $DUMMY_CMD = "dummy-command";

# Test results
my $tests_run = 0;
my $tests_passed = 0;
my $tests_failed = 0;
my @failures;

# Cleanup handler
$SIG{INT} = sub {
    print "\n\nCaught SIGINT, cleaning up...\n";
    cleanup();
    exit 1;
};

sub vprint {
    print @_ if $VERBOSE;
}

sub pass {
    my ($name) = @_;
    $tests_passed++;
    print "PASS: $name\n";
}

sub fail {
    my ($name, $reason) = @_;
    $tests_failed++;
    push @failures, "$name: $reason";
    print "FAIL: $name\n";
    print "  Reason: $reason\n" if $reason;
}

sub test_header {
    my ($name) = @_;
    $tests_run++;
    print "\n" . "=" x 60 . "\n";
    print "TEST $tests_run: $name\n";
    print "=" x 60 . "\n";
}

# Run a command and capture output
sub run_command {
    my ($cmd, $timeout) = @_;
    $timeout ||= 10;

    vprint "Running: $cmd\n";

    my $output = '';
    my $pid = open3(my $in, my $out, my $err = gensym, $cmd);
    close($in);

    my $sel = IO::Select->new($out, $err);
    my $start = time();

    while (time() - $start < $timeout) {
        my @ready = $sel->can_read(0.1);
        for my $fh (@ready) {
            my $data;
            my $n = sysread($fh, $data, 4096);
            if ($n) {
                $output .= $data;
                vprint $data;
            } else {
                $sel->remove($fh);
            }
        }

        # Check if process exited
        my $kid = waitpid($pid, WNOHANG);
        last if $kid > 0;
    }

    # Kill if still running
    if (kill(0, $pid)) {
        kill('TERM', $pid);
        waitpid($pid, 0);
    }

    my $exit_code = $? >> 8;
    return ($exit_code, $output);
}

# Run smak interactively with script
sub run_smak_interactive {
    my ($args, $script_ref, $timeout) = @_;
    $timeout ||= 30;

    my $cmd = "$SMAK $args";
    vprint "Starting interactive: $cmd\n";

    my $err = gensym;
    my $pid = open3(my $in, my $out, $err, $cmd);

    my $output = '';
    my $sel = IO::Select->new($out, $err);
    my $start = time();

    # Wait for prompt
    while (time() - $start < 5) {
        my @fhs = $sel->can_read(0.1);
        for my $fh (@fhs) {
            my $data;
            sysread($fh, $data, 4096);
            $output .= $data if $data;
            vprint $data if $data;
        }
        last if $output =~ /smak>/;
    }

    # Send commands
    for my $cmd (@$script_ref) {
        print $in "$cmd\n";
        vprint "Sent: $cmd\n";
        sleep(0.5);

        # Read response
        while (my @fhs = $sel->can_read(0.2)) {
            for my $fh (@fhs) {
                my $data;
                my $n = sysread($fh, $data, 4096);
                if (!$n) {
                    # EOF or error - remove from select
                    $sel->remove($fh);
                } elsif ($data) {
                    $output .= $data;
                    vprint $data;
                }
            }
        }
    }

    waitpid($pid, 0);
    my $exit_code = $? >> 8;
    return ($exit_code, $output);
}

# Setup test environment
sub setup_test_env {
    my ($num_sources, $num_objects) = @_;
    $num_sources ||= 3;
    $num_objects ||= 5;

    vprint "Setting up test environment in $TEST_DIR\n";

    # Clean previous test
    remove_tree($TEST_DIR) if -d $TEST_DIR;
    make_path($TEST_DIR);
    make_path($CACHE_DIR);

    chdir($TEST_DIR) or die "Cannot chdir to $TEST_DIR: $!";

    # Generate test Makefile and sources
    my ($exit, $output) = run_command("$TEST_GEN -s $num_sources -o $num_objects -t 2 -d .");

    if ($exit != 0) {
        die "Test generator failed: $output";
    }

    vprint "Test environment ready\n";
}

sub cleanup {
    chdir("/tmp") if -d "/tmp";
    remove_tree($TEST_DIR) if -d $TEST_DIR;

    # Kill any stray smak processes from this test
    system("pkill -f 'smak.*$TEST_DIR' 2>/dev/null");
}

# Test 1: Single-threaded build
sub test_single_threaded {
    test_header("Single-threaded build");
    setup_test_env(3, 5);

    my ($exit, $output) = run_command("$SMAK all", 30);

    if ($exit == 0) {
        pass("Single-threaded build");
    } else {
        fail("Single-threaded build", "Exit code: $exit");
    }
}

# Test 2: Parallel build
sub test_parallel_build {
    test_header("Parallel build (-j4)");
    setup_test_env(3, 5);

    my ($exit, $output) = run_command("$SMAK -j4 all", 30);

    if ($exit == 0) {
        pass("Parallel build");
    } else {
        fail("Parallel build", "Exit code: $exit");
    }
}

# Test 3: Interactive CLI basic commands
sub test_interactive_basic {
    test_header("Interactive CLI basic commands");
    setup_test_env(3, 5);

    my @script = (
        'b all',      # Build all
        'status',     # Check status
        'q',          # Quit
    );

    my ($exit, $output) = run_smak_interactive("-cli -j2", \@script, 30);

    if ($output =~ /Build succeeded/ || $output =~ /target/ || $exit == 0) {
        pass("Interactive basic commands");
    } else {
        fail("Interactive basic commands", "Build did not succeed");
    }
}

# Test 4: File removal and rebuild detection
sub test_file_removal {
    test_header("File removal and rebuild detection");
    setup_test_env(3, 5);

    # Initial build
    my ($exit1, $output1) = run_command("$SMAK all", 20);

    if ($exit1 != 0) {
        fail("File removal test", "Initial build failed");
        return;
    }

    # Find an object file and remove it
    my @objs = glob("*.o");
    if (@objs) {
        my $obj = $objs[0];
        vprint "Removing $obj\n";
        unlink($obj);

        # Rebuild
        my ($exit2, $output2) = run_command("$SMAK all", 20);

        if ($exit2 == 0 && -f $obj) {
            pass("File removal and rebuild");
        } else {
            fail("File removal and rebuild", "Rebuild failed or file not recreated");
        }
    } else {
        fail("File removal test", "No object files found");
    }
}

# Test 5: File modification (dirty) and rebuild
sub test_file_dirty {
    test_header("File modification and rebuild detection");
    setup_test_env(3, 5);

    # Initial build
    my ($exit1, $output1) = run_command("$SMAK all", 20);

    if ($exit1 != 0) {
        fail("File dirty test", "Initial build failed");
        return;
    }

    # Find a source file and modify it (test-generator creates src*.txt files)
    my @srcs = glob("src*.txt");
    push @srcs, glob("*.c") unless @srcs;  # Fallback to .c files
    if (@srcs) {
        my $src = $srcs[0];
        vprint "Modifying $src\n";
        sleep(1);  # Ensure mtime differs
        open(my $fh, '>>', $src);
        print $fh "# Modified\n";
        close($fh);

        # Rebuild
        my ($exit2, $output2) = run_command("$SMAK all", 20);

        if ($exit2 == 0) {
            pass("File modification and rebuild");
        } else {
            fail("File modification and rebuild", "Rebuild failed");
        }
    } else {
        fail("File dirty test", "No source files found");
    }
}

# Test 6: Caching - stop and restart
sub test_caching {
    test_header("State caching across restarts");
    setup_test_env(3, 5);

    # First build with caching enabled
    my $cache_dir = "$TEST_DIR/.cache";
    make_path($cache_dir) unless -d $cache_dir;

    local $ENV{SMAK_CACHE_DIR} = $cache_dir;
    my ($exit1, $output1) = run_command("SMAK_CACHE_DIR=$cache_dir $SMAK all", 30);

    if ($exit1 != 0) {
        fail("Caching test", "Initial build failed");
        return;
    }

    # Check cache was created
    if (!-f "$cache_dir/state.cache") {
        fail("Caching test", "Cache file not created");
        return;
    }

    # Second build - should use cache
    my ($exit2, $output2) = run_command("SMAK_CACHE_DIR=$cache_dir SMAK_DEBUG=1 $SMAK all 2>&1", 30);

    if ($output2 =~ /Using cached state|Cache loaded/) {
        pass("State caching");
    } else {
        # Cache exists but message not found - still pass if build succeeds
        if ($exit2 == 0 && -f "$cache_dir/state.cache") {
            pass("State caching");
        } else {
            fail("State caching", "Cache not used on second run");
        }
    }
}

# Test 7: Cache invalidation on Makefile change
sub test_cache_invalidation {
    test_header("Cache invalidation on Makefile change");
    setup_test_env(3, 5);

    my $cache_dir = "$TEST_DIR/.cache";
    make_path($cache_dir) unless -d $cache_dir;

    # First build
    my ($exit1, $output1) = run_command("SMAK_CACHE_DIR=$cache_dir $SMAK all", 30);

    if ($exit1 != 0) {
        fail("Cache invalidation", "Initial build failed");
        return;
    }

    # Modify Makefile
    sleep(1);
    open(my $fh, '>>', 'Makefile');
    print $fh "\n# Modified\n";
    close($fh);

    # Rebuild - cache should be invalidated
    my ($exit2, $output2) = run_command("SMAK_CACHE_DIR=$cache_dir $SMAK all", 30);

    if ($exit2 == 0) {
        pass("Cache invalidation (rebuilt)");
    } else {
        fail("Cache invalidation", "Rebuild failed after Makefile change");
    }
}

# Test 8: Ctrl-C interruption and restart
sub test_ctrl_c_restart {
    test_header("Ctrl-C interruption and restart");

    # Create custom test environment with a job that sends SIGINT
    vprint "Setting up Ctrl-C test environment\n";
    remove_tree($TEST_DIR) if -d $TEST_DIR;
    make_path($TEST_DIR);
    chdir($TEST_DIR) or die "Cannot chdir to $TEST_DIR: $!";

    # Create a Makefile where one job sends SIGINT mid-build
    open(my $mf, '>', 'Makefile') or die "Cannot create Makefile: $!";
    print $mf <<"EOF";
DUMMY := $DUMMY_CMD

.PHONY: all clean

all: target1 target2 target3

src1.txt:
\t\@echo "Source 1" > \$@

src2.txt:
\t\@echo "Source 2" > \$@

# This job sends SIGINT to parent during execution
obj1.o: src1.txt
\t\$(DUMMY) -sigint -in src1.txt -out \$@

obj2.o: src2.txt
\t\$(DUMMY) -in src2.txt -out \$@

obj3.o: src1.txt src2.txt
\t\$(DUMMY) -in src1.txt src2.txt -out \$@

target1: obj1.o obj2.o
\t\$(DUMMY) -in obj1.o obj2.o -out \$@

target2: obj2.o obj3.o
\t\$(DUMMY) -in obj2.o obj3.o -out \$@

target3: obj1.o obj3.o
\t\$(DUMMY) -in obj1.o obj3.o -out \$@

clean:
\trm -f src*.txt obj*.o target*
EOF
    close($mf);

    # Run smak - it should handle SIGINT from the job
    my ($exit, $output) = run_command("$SMAK -j2 all 2>&1", 30);

    # The build should either be interrupted or complete
    # Check that smak handled the SIGINT gracefully
    if ($output =~ /SIGINT|Sending SIGINT|interrupted/i || $exit != 0) {
        # SIGINT was sent and detected
        pass("Ctrl-C and restart");
    } elsif (-f "target1" || -f "target2" || -f "target3") {
        # Build completed despite SIGINT (signal was handled)
        pass("Ctrl-C and restart");
    } else {
        fail("Ctrl-C and restart", "No SIGINT handling detected (exit=$exit)");
    }
}

# Main
print "=" x 60 . "\n";
print "SMAK ADVANCED CLI TEST SUITE\n";
print "=" x 60 . "\n";
print "Test directory: $TEST_DIR\n";
print "Smak path: $SMAK\n";
print "Verbose: " . ($VERBOSE ? "yes" : "no") . "\n";

# Run tests
test_single_threaded();
test_parallel_build();
test_interactive_basic();
test_file_removal();
test_file_dirty();
test_caching();
test_cache_invalidation();
test_ctrl_c_restart();

# Cleanup
cleanup();

# Summary
print "\n" . "=" x 60 . "\n";
print "TEST SUMMARY\n";
print "=" x 60 . "\n";
print "Total:  $tests_run\n";
print "Passed: $tests_passed\n";
print "Failed: $tests_failed\n";

if (@failures) {
    print "\nFailures:\n";
    for my $f (@failures) {
        print "  - $f\n";
    }
}

exit($tests_failed > 0 ? 1 : 0);
