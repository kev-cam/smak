#!/bin/bash
# Regression test suite for smak
# Runs all test scripts and reports results

set +e  # Don't exit on error - we want to run all tests

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Parse arguments
FULL_MODE=0
VERBOSE=0
TTY_MODE=0
if [ "$1" = "--full" ] || [ "$1" = "-f" ]; then
    FULL_MODE=1
elif [ "$1" = "--verbose" ] || [ "$1" = "-v" ]; then
    VERBOSE=1
elif [ "$1" = "--tty" ] || [ "$1" = "-t" ]; then
    TTY_MODE=1
elif [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    cat << EOF
Usage: $0 [OPTIONS]

Run smak regression test suite.

By default, all tests including interactive ones are run automatically.
Interactive tests use script files (scripts/*.script) for automation.

All tests are run twice - once with cache disabled and once with cache enabled.
This ensures consistent behavior between cached and non-cached execution.

Options:
  (none)              Run all tests including scripted interactive tests
  -f, --full          Run full test suite including random builds and CLI tests
  -v, --verbose       Show test output
  -t, --tty           Run interactive tests with actual TTY input (not scripted)
  -h, --help          Show this help

Examples:
  $0                  # All tests with scripted automation (default)
  $0 --full           # Full test suite
  $0 --verbose        # Show all test output
  $0 --tty            # Interactive tests require user input

EOF
    exit 0
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Counters
TOTAL=0
PASSED=0
FAILED=0
SKIPPED=0

# Test results
declare -a FAILED_TESTS
declare -a PASSED_TESTS

echo "======================================"
echo "SMAK REGRESSION TEST SUITE"
echo "======================================"
echo ""
echo "Test modes: [Seq/NoCache] [Seq/Cache] [Par/NoCache] [Par/Cache] [Fail-test]"
echo "Results shown as: PPPPp (all pass + fail test works)"
echo "              or: PPPPx (all pass, no fail test)"
echo "              or: PPFPp (3rd mode failed, fail test works), etc."
echo ""

# Function to run a test script
run_test() {
    local test_script="$1"
    local test_name=$(basename "$test_script" .sh)

    ((TOTAL++))

    printf "Running %-40s ... " "$test_name"

    if [ ! -x "$test_script" ]; then
        echo -e "${YELLOW}SKIP${NC} (not executable)"
        ((SKIPPED++))
        return
    fi

    # Check if test uses interactive debug mode (-Kd flag)
    # Only treat as interactive if -Kd is the primary mode (heredoc or exec)
    local is_interactive=0
    if grep -q "cat.*<<.*|.*smak.*-Kd" "$test_script" 2>/dev/null || \
       grep -q "exec.*smak.*-Kd" "$test_script" 2>/dev/null; then
        is_interactive=1
    fi

    # Check if there's a script file for this test
    local script_file_path="scripts/${test_name}.script"
    local has_script=0
    local temp_script_file=""
    unset script_file

    if [ -f "$script_file_path" ]; then
        has_script=1
	script_file=$script_file_path
    elif [ $is_interactive -eq 1 ] && [ $TTY_MODE -eq 0 ]; then
        # For interactive tests without script file, extract commands from heredoc
        # Look for heredoc pattern: cat <<EOF | ../smak -Kd
        if grep -q "cat.*<<.*|.*smak.*-Kd" "$test_script" 2>/dev/null; then
            # Extract commands from heredoc (between <<EOF and EOF)
            temp_script_file="/tmp/smak-script-${test_name}-$$.script"
            sed -n '/cat.*<<.*|.*smak.*-Kd/,/^EOF$/p' "$test_script" | \
                sed '1d;$d' > "$temp_script_file"
            script_file="$temp_script_file"
            has_script=2
        fi
    fi

    # Interactive tests in --tty mode will run with user input
    # Otherwise use script runner for automation

    # Run test and capture output for all 4 modes
    local output_seq_nocache output_seq_cache output_par_nocache output_par_cache
    local result_seq_nocache result_seq_cache result_par_nocache result_par_cache
    local start_time=$(date +%s)

    # Verbose mode shows output but still uses proper handling
    local show_output=$VERBOSE

    if [ $show_output -eq 1 ]; then
        echo ""
    fi

    # Helper function to run a single mode
    run_single_mode() {
        local mode_cache="$1"  # "off" or "default"
        local mode_jobs="$2"   # "" (sequential) or "-j4" (parallel)
        local output_file="$3"  # temp file to store output

        if [ $is_interactive -eq 1 ] && [ $has_script -ne 0 ] && [ $TTY_MODE -eq 0 ]; then
            # Extract smak arguments from test script (e.g., -f Makefile.test)
            local smak_args=$(grep -oP '(?<=smak ).*(?=-Kd)' "$test_script" | head -1)

            # Create wrapper script that execs smak directly with jobs arg
            local wrapper_script="/tmp/smak-wrapper-${test_name}-$$.sh"
            cat > "$wrapper_script" << WRAPPER_EOF
#!/bin/bash
cd "\$(dirname "$0")"
exec ../smak $smak_args $mode_jobs -Kd
WRAPPER_EOF
            chmod +x "$wrapper_script"

            # Run with script automation using run-with-script.pl (with timeout)
            timeout 30 env SMAK_CACHE_DIR=$mode_cache ./run-with-script.pl "$script_file" "$wrapper_script" >"$output_file" 2>&1
            local result=$?
            rm -f "$wrapper_script"
            return $result

        elif [ $is_interactive -eq 1 ] && [ $TTY_MODE -eq 1 ]; then
            # For TTY mode, we can't easily inject -j, skip parallel testing
            if [ -n "$mode_jobs" ]; then
                return 0  # Skip parallel in TTY mode
            fi
            timeout 60 env SMAK_CACHE_DIR=$mode_cache ./"$test_script" >"$output_file" 2>&1
            return $?

        else
            # Default: non-interactive tests, redirect stdin (with timeout)
            # For parallel mode, modify the test script invocation
            if [ -n "$mode_jobs" ]; then
                # Inject -j4 into smak invocation
                timeout 30 env SMAK_CACHE_DIR=$mode_cache bash -c "sed 's/\(smak[^-]*\)/\1 -j4 /' '$test_script' | bash" >"$output_file" 2>&1 < "${script_file:-/dev/null}"
            else
                timeout 30 env SMAK_CACHE_DIR=$mode_cache ./"$test_script" >"$output_file" 2>&1 < "${script_file:-/dev/null}"
            fi
            return $?
        fi
    }

    # Create temp files for output
    local out_seq_nc="/tmp/smak-test-${test_name}-seq-nc-$$.log"
    local out_seq_c="/tmp/smak-test-${test_name}-seq-c-$$.log"
    local out_par_nc="/tmp/smak-test-${test_name}-par-nc-$$.log"
    local out_par_c="/tmp/smak-test-${test_name}-par-c-$$.log"

    # Run all 4 modes
    run_single_mode "off" "" "$out_seq_nc"
    result_seq_nocache=$?
    if [ $result_seq_nocache -eq 124 ]; then
        echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
        ((FAILED++))
        [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
        return
    fi

    run_single_mode "default" "" "$out_seq_c"
    result_seq_cache=$?
    if [ $result_seq_cache -eq 124 ]; then
        echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
        ((FAILED++))
        [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
        return
    fi

    run_single_mode "off" "-j4" "$out_par_nc"
    result_par_nocache=$?
    if [ $result_par_nocache -eq 124 ]; then
        echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
        ((FAILED++))
        [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
        return
    fi

    run_single_mode "default" "-j4" "$out_par_c"
    result_par_cache=$?
    if [ $result_par_cache -eq 124 ]; then
        echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
        ((FAILED++))
        [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
        return
    fi

    # Clean up temp script file
    [ -n "$temp_script_file" ] && rm -f "$temp_script_file"

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Display output in verbose mode
    if [ $show_output -eq 1 ]; then
        echo "=== Sequential/NoCache ==="
        cat "$out_seq_nc"
        echo ""
        echo "=== Sequential/Cache ==="
        cat "$out_seq_c"
        echo ""
        echo "=== Parallel/NoCache ==="
        cat "$out_par_nc"
        echo ""
        echo "=== Parallel/Cache ==="
        cat "$out_par_c"
        echo ""
    fi

    # Build result string (PPPP or PPFP etc.)
    local result_str=""
    local all_passed=1

    # Mode 1: Sequential + NoCache
    if [ $result_seq_nocache -eq 0 ]; then
        result_str="${result_str}P"
    else
        result_str="${result_str}F"
        all_passed=0
    fi

    # Mode 2: Sequential + Cache
    if [ $result_seq_cache -eq 0 ]; then
        result_str="${result_str}P"
    else
        result_str="${result_str}F"
        all_passed=0
    fi

    # Mode 3: Parallel + NoCache
    if [ $result_par_nocache -eq 0 ]; then
        result_str="${result_str}P"
    else
        result_str="${result_str}F"
        all_passed=0
    fi

    # Mode 4: Parallel + Cache
    if [ $result_par_cache -eq 0 ]; then
        result_str="${result_str}P"
    else
        result_str="${result_str}F"
        all_passed=0
    fi

    # Check for -fail test
    local fail_test="${test_script%.sh}-fail.sh"
    if [ -f "$fail_test" ] && [ -x "$fail_test" ]; then
        # Run the fail test (just sequential/no-cache)
        local fail_output="/tmp/smak-test-${test_name}-fail-$$.log"
        timeout 30 env SMAK_CACHE_DIR=off ./"$(basename "$fail_test")" >"$fail_output" 2>&1 < /dev/null
        local fail_result=$?

        # The fail test should fail (non-zero exit code)
        if [ $fail_result -ne 0 ] && [ $fail_result -ne 124 ]; then
            result_str="${result_str}p"
        else
            # Fail test passed when it should have failed, or timed out
            result_str="${result_str}F"
            all_passed=0
        fi
        rm -f "$fail_output"
    else
        # No fail test exists
        result_str="${result_str}x"
    fi

    # Display result
    if [ $all_passed -eq 1 ]; then
        echo -e "${GREEN}${result_str}${NC} (${duration}s)"
        ((PASSED++))
        PASSED_TESTS+=("$test_name")
        # Clean up temp files on success
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
    else
        echo -e "${RED}${result_str}${NC} (${duration}s)"
        ((FAILED++))
        FAILED_TESTS+=("$test_name")
        # Save failure details
        if [ $VERBOSE -eq 0 ]; then
            local fail_log="/tmp/smak-test-fail-$test_name.log"
            {
                echo "Test: $test_name"
                echo "Results: Seq/NoCache=$result_seq_nocache Seq/Cache=$result_seq_cache Par/NoCache=$result_par_nocache Par/Cache=$result_par_cache"
                echo "Result string: $result_str"
                echo ""
                echo "=== Sequential/NoCache Output ==="
                cat "$out_seq_nc"
                echo ""
                echo "=== Sequential/Cache Output ==="
                cat "$out_seq_c"
                echo ""
                echo "=== Parallel/NoCache Output ==="
                cat "$out_par_nc"
                echo ""
                echo "=== Parallel/Cache Output ==="
                cat "$out_par_c"
            } > "$fail_log"
        fi
        # Clean up temp files after saving to fail log
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
    fi
}

# Run all test_*.sh scripts (non-interactive unit tests)
echo "Unit Tests:"
echo "----------"
for test in test_*.sh; do
    if [ -f "$test" ]; then
        run_test "$test"
    fi
done

# Run default target test
echo ""
echo "Default Target Tests:"
echo "--------------------"
if [ -f "test-default-target.sh" ]; then
    run_test "test-default-target.sh"
fi

# Run generator-based tests if in full mode
if [ $FULL_MODE -eq 1 ]; then
    echo ""
    echo "Random Build Tests:"
    echo "------------------"
    echo "(Running 10 iterations, may take 1-2 minutes...)"

    if [ -x "./run-tests" ]; then
        # Run test-generator tests
        if [ $VERBOSE -eq 1 ]; then
            ./run-tests -f 5 -t 60 -v
            local gen_result=$?
        else
            ./run-tests -f 5 -t 60 > /tmp/smak-generator-test.log 2>&1
            local gen_result=$?
        fi

        if [ $gen_result -eq 0 ]; then
            echo -e "Random builds:                            ${GREEN}PASS${NC}"
            ((PASSED++))
            ((TOTAL++))
        else
            echo -e "Random builds:                            ${RED}FAIL${NC}"
            ((FAILED++))
            ((TOTAL++))
            FAILED_TESTS+=("random-builds")
        fi
    else
        echo -e "run-tests not found:                      ${YELLOW}SKIP${NC}"
        ((SKIPPED++))
        ((TOTAL++))
    fi
fi

# Run CLI tests if in full mode
if [ $FULL_MODE -eq 1 ]; then
    echo ""
    echo "CLI Tests:"
    echo "---------"

    if [ -x "./test-cli-advanced" ]; then
        if [ $VERBOSE -eq 1 ]; then
            ./test-cli-advanced
            local cli_result=$?
        else
            ./test-cli-advanced > /tmp/smak-cli-test.log 2>&1
            local cli_result=$?
        fi

        if [ $cli_result -eq 0 ]; then
            echo -e "Advanced CLI tests:                       ${GREEN}PASS${NC}"
            ((PASSED++))
            ((TOTAL++))
        else
            echo -e "Advanced CLI tests:                       ${RED}FAIL${NC}"
            ((FAILED++))
            ((TOTAL++))
            FAILED_TESTS+=("cli-tests")
        fi
    else
        echo -e "test-cli-advanced not found:              ${YELLOW}SKIP${NC}"
        ((SKIPPED++))
        ((TOTAL++))
    fi
fi

# Summary
echo ""
echo "======================================"
echo "TEST SUMMARY"
echo "======================================"
echo "Total tests:   $TOTAL"
echo -e "Passed:        ${GREEN}$PASSED${NC}"
echo -e "Failed:        ${RED}$FAILED${NC}"
echo -e "Skipped:       ${YELLOW}$SKIPPED${NC}"

if [ $FAILED -gt 0 ]; then
    echo ""
    echo "Failed tests:"
    for test in "${FAILED_TESTS[@]}"; do
        echo -e "  ${RED}âœ—${NC} $test"
        if [ -f "/tmp/smak-test-fail-$test.log" ]; then
            echo "     Log: /tmp/smak-test-fail-$test.log"
        fi
    done
    echo ""
    echo "Tip: Run with --verbose to see test output"
fi

echo ""
if [ $FAILED -eq 0 ]; then
    echo -e "${GREEN}All tests passed!${NC}"
    if [ $FULL_MODE -eq 0 ]; then
        echo ""
        echo "Note: This was a quick regression test."
        echo "Run '$0 --full' for comprehensive testing including:"
        echo "  - Random build tests (test-generator)"
        echo "  - CLI interaction tests"
    fi
    exit 0
else
    echo -e "${RED}Some tests failed.${NC}"
    exit 1
fi
