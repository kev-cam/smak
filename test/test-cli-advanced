#!/usr/bin/env perl
# Advanced CLI testing for smak: tests builds, caching, file changes, Ctrl-C
use strict;
use warnings;
use IPC::Open3;
use IO::Select;
use Symbol 'gensym';
use POSIX ":sys_wait_h";
use File::Path qw(remove_tree make_path);
use Cwd 'abs_path';
use File::Basename;
use Time::HiRes qw(sleep time);

# Get the directory where this script lives and add it to PATH
my $SCRIPT_DIR = dirname(abs_path($0));
$ENV{PATH} = "$SCRIPT_DIR:$ENV{PATH}";

# Configuration - use /tmp to avoid accidental deletion of test files
my $VERBOSE = $ENV{TEST_VERBOSE} || 0;
my $TEST_DIR = "/tmp/smak-test-cli-$$";
my $CACHE_DIR = "$TEST_DIR/.cache";
my $SMAK = "$SCRIPT_DIR/../smak";
my $TEST_GEN = "test-generator";
my $DUMMY_CMD = "dummy-command";

# Test results
my $tests_run = 0;
my $tests_passed = 0;
my $tests_failed = 0;
my @failures;

# Cleanup handler
$SIG{INT} = sub {
    print "\n\nCaught SIGINT, cleaning up...\n";
    cleanup();
    exit 1;
};

sub vprint {
    print @_ if $VERBOSE;
}

sub pass {
    my ($name) = @_;
    $tests_passed++;
    print "PASS: $name\n";
}

sub fail {
    my ($name, $reason) = @_;
    $tests_failed++;
    push @failures, "$name: $reason";
    print "FAIL: $name\n";
    print "  Reason: $reason\n" if $reason;
}

sub test_header {
    my ($name) = @_;
    $tests_run++;
    print "\n" . "=" x 60 . "\n";
    print "TEST $tests_run: $name\n";
    print "=" x 60 . "\n";
}

# Run a command and capture output
sub run_command {
    my ($cmd, $timeout) = @_;
    $timeout ||= 10;

    vprint "Running: $cmd\n";

    my $output = '';
    my $pid = open3(my $in, my $out, my $err = gensym, $cmd);
    close($in);

    my $sel = IO::Select->new($out, $err);
    my $start = time();

    while (time() - $start < $timeout) {
        my @ready = $sel->can_read(0.1);
        for my $fh (@ready) {
            my $data;
            my $n = sysread($fh, $data, 4096);
            if ($n) {
                $output .= $data;
                vprint $data;
            } else {
                $sel->remove($fh);
            }
        }

        # Check if process exited
        my $kid = waitpid($pid, WNOHANG);
        last if $kid > 0;
    }

    # Kill if still running
    if (kill(0, $pid)) {
        kill('TERM', $pid);
        waitpid($pid, 0);
    }

    my $exit_code = $? >> 8;
    return ($exit_code, $output);
}

# Run smak interactively with script
sub run_smak_interactive {
    my ($args, $script_ref, $timeout) = @_;
    $timeout ||= 30;

    require IO::Pty;
    my $pty = IO::Pty->new();
    my $slave = $pty->slave();
    my @cmd = ($SMAK, split(/\s+/, $args));
    vprint "Starting interactive (pty): @cmd\n";

    my $pid = fork();
    die "Fork failed: $!" unless defined $pid;

    if ($pid == 0) {
        # Child: set up pty as controlling terminal
        close($pty);
        POSIX::setsid();
        open(STDIN,  '<&', $slave) or die "dup stdin: $!";
        open(STDOUT, '>&', $slave) or die "dup stdout: $!";
        open(STDERR, '>&', $slave) or die "dup stderr: $!";
        close($slave);
        exec(@cmd);
        exit 1;
    }

    # Parent: close slave, use master side of the pty
    close($slave);
    my $output = '';
    my $sel = IO::Select->new($pty);
    my $start = time();

    # Wait for prompt
    while (time() - $start < 5) {
        my @fhs = $sel->can_read(0.1);
        for my $fh (@fhs) {
            my $data;
            sysread($fh, $data, 4096);
            $output .= $data if $data;
            vprint $data if $data;
        }
        last if $output =~ /smak>/;
    }

    # Send commands
    for my $cmd (@$script_ref) {
        print $pty "$cmd\r";
        vprint "Sent: $cmd\n";
        sleep(0.5);

        # Read response
        while (my @fhs = $sel->can_read(0.5)) {
            for my $fh (@fhs) {
                my $data;
                my $n = sysread($fh, $data, 4096);
                last unless $n;
                $output .= $data;
                vprint $data;
            }
        }
    }

    # Wait with timeout, kill if hung
    my $wait_start = time();
    my $reaped = 0;
    while (time() - $wait_start < $timeout) {
        my $r = waitpid($pid, WNOHANG);
        if ($r != 0) { $reaped = 1; last; }
        sleep(0.2);
    }
    if (!$reaped) {
        kill('TERM', $pid);
        sleep(0.5);
        kill('KILL', $pid);
        waitpid($pid, 0);
    }
    close($pty);
    my $exit_code = $? >> 8;
    return ($exit_code, $output);
}

# Setup test environment
sub setup_test_env {
    my ($num_sources, $num_objects) = @_;
    $num_sources ||= 3;
    $num_objects ||= 5;

    vprint "Setting up test environment in $TEST_DIR\n";

    # Clean previous test
    remove_tree($TEST_DIR) if -d $TEST_DIR;
    make_path($TEST_DIR);
    make_path($CACHE_DIR);

    chdir($TEST_DIR) or die "Cannot chdir to $TEST_DIR: $!";

    # Generate test Makefile and sources
    my ($exit, $output) = run_command("$TEST_GEN -s $num_sources -o $num_objects -t 2 -d .");

    if ($exit != 0) {
        die "Test generator failed: $output";
    }

    vprint "Test environment ready\n";
}

sub cleanup {
    chdir("/tmp") if -d "/tmp";
    remove_tree($TEST_DIR) if -d $TEST_DIR;

    # Kill any stray smak processes from this test
    system("pkill -f 'smak.*$TEST_DIR' 2>/dev/null");
}

# Test 1: Single-threaded build
sub test_single_threaded {
    test_header("Single-threaded build");
    setup_test_env(3, 5);

    my ($exit, $output) = run_command("$SMAK all", 30);

    if ($exit == 0) {
        pass("Single-threaded build");
    } else {
        fail("Single-threaded build", "Exit code: $exit");
    }
}

# Test 2: Parallel build
sub test_parallel_build {
    test_header("Parallel build (-j4)");
    setup_test_env(3, 5);

    my ($exit, $output) = run_command("$SMAK -j4 all", 30);

    if ($exit == 0) {
        pass("Parallel build");
    } else {
        fail("Parallel build", "Exit code: $exit");
    }
}

# Test 3: Interactive CLI basic commands
sub test_interactive_basic {
    test_header("Interactive CLI basic commands");
    setup_test_env(3, 5);

    my @script = (
        'b all',      # Build all
        'status',     # Check status
        'q',          # Quit
    );

    my ($exit, $output) = run_smak_interactive("-cli -j2", \@script, 30);

    if ($output =~ /Build succeeded/ || $output =~ /target/ || $exit == 0) {
        pass("Interactive basic commands");
    } else {
        fail("Interactive basic commands", "Build did not succeed");
    }
}

# Test 4: File removal and rebuild detection
sub test_file_removal {
    test_header("File removal and rebuild detection");
    setup_test_env(3, 5);

    # Initial build
    my ($exit1, $output1) = run_command("$SMAK all", 20);

    if ($exit1 != 0) {
        fail("File removal test", "Initial build failed");
        return;
    }

    # Find an object file and remove it
    my @objs = glob("*.o");
    if (@objs) {
        my $obj = $objs[0];
        vprint "Removing $obj\n";
        unlink($obj);

        # Rebuild
        my ($exit2, $output2) = run_command("$SMAK all", 20);

        if ($exit2 == 0 && -f $obj) {
            pass("File removal and rebuild");
        } else {
            fail("File removal and rebuild", "Rebuild failed or file not recreated");
        }
    } else {
        fail("File removal test", "No object files found");
    }
}

# Test 5: File modification (dirty) and rebuild
sub test_file_dirty {
    test_header("File modification and rebuild detection");
    setup_test_env(3, 5);

    # Initial build
    my ($exit1, $output1) = run_command("$SMAK all", 20);

    if ($exit1 != 0) {
        fail("File dirty test", "Initial build failed");
        return;
    }

    # Find a source file and modify it (test-generator creates src*.txt files)
    my @srcs = glob("src*.txt");
    push @srcs, glob("*.c") unless @srcs;  # Fallback to .c files
    if (@srcs) {
        my $src = $srcs[0];
        vprint "Modifying $src\n";
        sleep(1);  # Ensure mtime differs
        open(my $fh, '>>', $src);
        print $fh "# Modified\n";
        close($fh);

        # Rebuild
        my ($exit2, $output2) = run_command("$SMAK all", 20);

        if ($exit2 == 0) {
            pass("File modification and rebuild");
        } else {
            fail("File modification and rebuild", "Rebuild failed");
        }
    } else {
        fail("File dirty test", "No source files found");
    }
}

# Test 6: Caching - stop and restart
sub test_caching {
    test_header("State caching across restarts");
    setup_test_env(3, 5);

    # First build with caching enabled
    my $cache_dir = "$TEST_DIR/.cache";
    make_path($cache_dir) unless -d $cache_dir;

    local $ENV{SMAK_CACHE_DIR} = $cache_dir;
    my ($exit1, $output1) = run_command("SMAK_CACHE_DIR=$cache_dir $SMAK all", 30);

    if ($exit1 != 0) {
        fail("Caching test", "Initial build failed");
        return;
    }

    # Check cache was created
    if (!-f "$cache_dir/state.cache") {
        fail("Caching test", "Cache file not created");
        return;
    }

    # Second build - should use cache
    my ($exit2, $output2) = run_command("SMAK_CACHE_DIR=$cache_dir SMAK_DEBUG=1 $SMAK all 2>&1", 30);

    if ($output2 =~ /Using cached state|Cache loaded/) {
        pass("State caching");
    } else {
        # Cache exists but message not found - still pass if build succeeds
        if ($exit2 == 0 && -f "$cache_dir/state.cache") {
            pass("State caching");
        } else {
            fail("State caching", "Cache not used on second run");
        }
    }
}

# Test 7: Cache invalidation on Makefile change
sub test_cache_invalidation {
    test_header("Cache invalidation on Makefile change");
    setup_test_env(3, 5);

    my $cache_dir = "$TEST_DIR/.cache";
    make_path($cache_dir) unless -d $cache_dir;

    # First build
    my ($exit1, $output1) = run_command("SMAK_CACHE_DIR=$cache_dir $SMAK all", 30);

    if ($exit1 != 0) {
        fail("Cache invalidation", "Initial build failed");
        return;
    }

    # Modify Makefile
    sleep(1);
    open(my $fh, '>>', 'Makefile');
    print $fh "\n# Modified\n";
    close($fh);

    # Rebuild - cache should be invalidated
    my ($exit2, $output2) = run_command("SMAK_CACHE_DIR=$cache_dir $SMAK all", 30);

    if ($exit2 == 0) {
        pass("Cache invalidation (rebuilt)");
    } else {
        fail("Cache invalidation", "Rebuild failed after Makefile change");
    }
}

# Test 8: Ctrl-C interruption and restart
sub test_ctrl_c_restart {
    test_header("Ctrl-C interruption and restart");

    # Create custom test environment with a job that sends SIGINT
    vprint "Setting up Ctrl-C test environment\n";
    remove_tree($TEST_DIR) if -d $TEST_DIR;
    make_path($TEST_DIR);
    chdir($TEST_DIR) or die "Cannot chdir to $TEST_DIR: $!";

    # Create a Makefile where one job sends SIGINT mid-build
    open(my $mf, '>', 'Makefile') or die "Cannot create Makefile: $!";
    print $mf <<"EOF";
DUMMY := $DUMMY_CMD

.PHONY: all clean

all: target1 target2 target3

src1.txt:
\t\@echo "Source 1" > \$@

src2.txt:
\t\@echo "Source 2" > \$@

# This job sends SIGINT to parent during execution
obj1.o: src1.txt
\t\$(DUMMY) -sigint -in src1.txt -out \$@

obj2.o: src2.txt
\t\$(DUMMY) -in src2.txt -out \$@

obj3.o: src1.txt src2.txt
\t\$(DUMMY) -in src1.txt src2.txt -out \$@

target1: obj1.o obj2.o
\t\$(DUMMY) -in obj1.o obj2.o -out \$@

target2: obj2.o obj3.o
\t\$(DUMMY) -in obj2.o obj3.o -out \$@

target3: obj1.o obj3.o
\t\$(DUMMY) -in obj1.o obj3.o -out \$@

clean:
\trm -f src*.txt obj*.o target*
EOF
    close($mf);

    # Run smak - it should handle SIGINT from the job
    my ($exit, $output) = run_command("$SMAK -j2 all 2>&1", 30);

    # The build should either be interrupted or complete
    # Check that smak handled the SIGINT gracefully
    if ($output =~ /SIGINT|Sending SIGINT|interrupted/i || $exit != 0) {
        # SIGINT was sent and detected
        pass("Ctrl-C and restart");
    } elsif (-f "target1" || -f "target2" || -f "target3") {
        # Build completed despite SIGINT (signal was handled)
        pass("Ctrl-C and restart");
    } else {
        fail("Ctrl-C and restart", "No SIGINT handling detected (exit=$exit)");
    }
}

# Test 9: SIGINT properly kills job-server and workers
sub test_sigint_cleanup {
    test_header("SIGINT cleanup (job-server shutdown)");

    # Create test environment
    vprint "Setting up SIGINT cleanup test environment\n";
    remove_tree($TEST_DIR) if -d $TEST_DIR;
    make_path($TEST_DIR);
    chdir($TEST_DIR) or die "Cannot chdir to $TEST_DIR: $!";

    # Create a Makefile with a long-running job
    open(my $mf, '>', 'Makefile') or die "Cannot create Makefile: $!";
    print $mf <<"EOF";
all: slow.txt

slow.txt:
\tsleep 60 && echo "done" > slow.txt
EOF
    close($mf);

    # Start smak in its own process group so SIGINT reaches all children
    my $pid = fork();
    die "Fork failed: $!" unless defined $pid;

    if ($pid == 0) {
        # Child: new process group, then exec smak
        setpgrp(0, 0);
        open(STDOUT, '>/dev/null');
        open(STDERR, '>/dev/null');
        exec($SMAK, '-j4', 'all');
        exit 1;
    }

    # Parent: wait for job-server to start, then send SIGINT
    sleep 2;

    # Find the server PID via .smak.connect
    my $connect = "$TEST_DIR/.smak.connect";
    my $server_pid;
    if (-l $connect || -f $connect) {
        my $pf = readlink($connect) || $connect;
        ($server_pid) = ($pf =~ /smak-jobserver-(\d+)\.port/);
    }
    my $server_alive_before = $server_pid && kill(0, $server_pid);
    vprint "Server PID: $server_pid, alive before: $server_alive_before\n";

    # Send SIGINT to the process group (negative PID = group)
    kill '-INT', $pid;

    # Wait for cleanup
    sleep 3;
    waitpid($pid, WNOHANG);

    # Check if server exited
    my $server_alive_after = $server_pid && kill(0, $server_pid);
    vprint "Server alive after: $server_alive_after\n";

    if ($server_alive_before && !$server_alive_after) {
        pass("SIGINT cleanup (job-server shutdown)");
    } elsif (!$server_alive_before) {
        fail("SIGINT cleanup (job-server shutdown)", "Server not running before SIGINT");
    } else {
        fail("SIGINT cleanup (job-server shutdown)", "Server (PID $server_pid) still running after SIGINT");
        kill('-KILL', $pid);  # Force cleanup
        kill('KILL', $server_pid) if $server_pid;
    }
}

# Test 10: Idle timeout - detached job-server exits after timeout
sub test_idle_timeout {
    test_header("Idle timeout (detached job-server auto-exit)");

    vprint "Setting up idle timeout test environment\n";
    remove_tree($TEST_DIR) if -d $TEST_DIR;
    make_path($TEST_DIR);
    chdir($TEST_DIR) or die "Cannot chdir to $TEST_DIR: $!";

    # Create a simple Makefile
    open(my $mf, '>', 'Makefile') or die "Cannot create Makefile: $!";
    print $mf <<"EOF";
all: hello.txt

hello.txt:
\techo "hello" > hello.txt
EOF
    close($mf);

    # Create .smak.rc with short idle timeout (5 seconds)
    open(my $rc, '>', '.smak.rc') or die "Cannot create .smak.rc: $!";
    print $rc "set job_server_idle_timeout = 5\n";
    close($rc);

    # Build with -j4 to start job server (it will detach when smak exits)
    my ($exit, $output) = run_command("$SMAK -j4 all 2>&1", 20);

    if ($exit != 0) {
        fail("Idle timeout", "Build failed (exit=$exit)");
        return;
    }

    # Check that .smak.connect exists (server still alive after build)
    my $connect_file = "$TEST_DIR/.smak.connect";
    if (! -l $connect_file && ! -f $connect_file) {
        fail("Idle timeout", ".smak.connect not found after build");
        return;
    }

    # Read the port file to get the server PID
    my $port_file = readlink($connect_file) || $connect_file;
    my $server_pid;
    if ($port_file =~ /smak-jobserver-(\d+)\.port/) {
        $server_pid = $1;
    }
    vprint "Job-server PID: $server_pid, port file: $port_file\n";

    # Verify server process is running
    if ($server_pid && !kill(0, $server_pid)) {
        fail("Idle timeout", "Job-server (PID $server_pid) not running after build");
        return;
    }
    vprint "Job-server is running\n";

    # Wait for idle timeout (5s) plus margin
    vprint "Waiting for idle timeout (8 seconds)...\n";
    sleep(8);

    # Check that server has exited
    my $server_gone = !$server_pid || !kill(0, $server_pid);
    my $connect_gone = ! -l $connect_file && ! -f $connect_file;

    if ($server_gone && $connect_gone) {
        pass("Idle timeout (server exited after timeout)");
    } elsif ($server_gone) {
        pass("Idle timeout (server exited, connect file already cleaned)");
    } else {
        fail("Idle timeout", "Job-server (PID $server_pid) still running after timeout");
        # Clean up
        kill('TERM', $server_pid) if $server_pid;
    }
}

# Main
print "=" x 60 . "\n";
print "SMAK ADVANCED CLI TEST SUITE\n";
print "=" x 60 . "\n";
print "Test directory: $TEST_DIR\n";
print "Smak path: $SMAK\n";
print "Verbose: " . ($VERBOSE ? "yes" : "no") . "\n";

# Run tests
test_single_threaded();
test_parallel_build();
if ($ENV{SKIP_INTERACTIVE}) {
    test_header("Interactive CLI basic commands");
    print "SKIP: Interactive CLI (SKIP_INTERACTIVE set)\n";
} else {
    test_interactive_basic();
}
test_file_removal();
test_file_dirty();
test_caching();
test_cache_invalidation();
test_ctrl_c_restart();
test_sigint_cleanup();
test_idle_timeout();

# Cleanup
cleanup();

# Summary
print "\n" . "=" x 60 . "\n";
print "TEST SUMMARY\n";
print "=" x 60 . "\n";
print "Total:  $tests_run\n";
print "Passed: $tests_passed\n";
print "Failed: $tests_failed\n";

if (@failures) {
    print "\nFailures:\n";
    for my $f (@failures) {
        print "  - $f\n";
    }
}

exit($tests_failed > 0 ? 1 : 0);
