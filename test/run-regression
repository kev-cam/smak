#!/bin/bash
# Regression test suite for smak
# Runs all test scripts and reports results

set +e  # Don't exit on error - we want to run all tests

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Parse arguments
FULL_MODE=0
VERBOSE=0
TTY_MODE=0
CLONE_MODE=""
SANITY_MODE=0
LIST_MODE=0
FILTER_PATTERN=""
NO_PARALLEL=0
FAST_MODE=0
PARALLEL_JOBS=1
SMAK_EXTRA_ARGS=""

while [ $# -gt 0 ]; do
    case "$1" in
        -j)
            PARALLEL_JOBS="$2"
            if ! [[ "$PARALLEL_JOBS" =~ ^[0-9]+$ ]] || [ "$PARALLEL_JOBS" -lt 1 ]; then
                echo "Error: -j requires a positive integer argument"
                exit 1
            fi
            shift 2
            ;;
        -f|--full)
            FULL_MODE=1
            shift
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -t|--tty)
            TTY_MODE=1
            shift
            ;;
        -s|--sanity)
            SANITY_MODE=1
            shift
            ;;
        -l|--list)
            LIST_MODE=1
            shift
            ;;
        --filter)
            FILTER_PATTERN="$2"
            if [ -z "$FILTER_PATTERN" ]; then
                echo "Error: --filter requires a pattern argument"
                exit 1
            fi
            shift 2
            ;;
        --no-parallel)
            NO_PARALLEL=1
            shift
            ;;
        --fast)
            FAST_MODE=1
            shift
            ;;
        -clone|--clone)
            CLONE_MODE="$2"
            if [ "$CLONE_MODE" != "local" ] && [ "$CLONE_MODE" != "query" ]; then
                echo "Error: -clone requires 'local' or 'query' argument"
                exit 1
            fi
            shift 2
            ;;
        -h|--help)
            cat << EOF
Usage: $0 [OPTIONS] [-- SMAK_OPTIONS]

Run smak regression test suite.

By default, all tests including interactive ones are run automatically.
Interactive tests use script files (scripts/*.script) for automation.

All tests are run in 4 modes: sequential/parallel × cache/no-cache
Each test's -fail variant is also run in all 4 modes to verify error handling.

Options:
  (none)              Run all tests including scripted interactive tests
  -j <N>              Run N tests in parallel (default: 1)
  -s, --sanity        Run quick sanity check (2 basic non-interactive tests)
  -f, --full          Run full test suite including random builds and CLI tests
  -v, --verbose       Show test output
  -t, --tty           Run interactive tests with actual TTY input (not scripted)
  -l, --list          List all tests that would be run and exit
  --filter <pattern>  Run only tests matching pattern (grep -E compatible)
  --no-parallel       Skip parallel test modes (only test sequential behavior)
  --fast              Skip remaining modes on first failure (mark skipped with -)
  -clone local        Clone from local repository to /tmp/smak/test-<tag>/ and run tests there
  -clone query        Clone from remote, prompting for branch selection
  -h, --help          Show this help

Any unrecognized options are passed through to smak (e.g., -norc, -K, etc.)

Isolating tests from user configuration:
  1. Pass -norc flag:              $0 -norc
  2. Use SMAK_RCFILE env var:      SMAK_RCFILE=/dev/null $0
  3. Use test rc file:             SMAK_RCFILE=.smak.test.rc $0

Examples:
  $0                  # All tests with scripted automation (default)
  $0 -j 4             # Run 4 tests in parallel for faster execution
  $0 --sanity         # Quick sanity check (2 non-interactive tests)
  $0 --full           # Full test suite
  $0 --verbose        # Show all test output
  $0 --tty            # Interactive tests require user input
  $0 --list           # Show what tests would run
  $0 --filter autorescan  # Run only tests matching 'autorescan'
  $0 --filter "debug|builtin"  # Run tests matching 'debug' or 'builtin'
  $0 -clone local     # Test in clean clone of local repo
  $0 -clone query     # Test in clone, choose branch interactively
  $0 -norc            # Run tests with smak -norc (ignore user config)
  $0 -- -norc -K      # Pass -norc and -K to smak
  SMAK_RCFILE=/dev/null $0      # Use empty rc file
  SMAK_RCFILE=.smak.test.rc $0  # Use minimal test rc file

EOF
            exit 0
            ;;
        --)
            shift
            SMAK_EXTRA_ARGS="$*"
            break
            ;;
        *)
            # Unrecognized options are passed to smak
            SMAK_EXTRA_ARGS="$SMAK_EXTRA_ARGS $1"
            shift
            ;;
    esac
done

# Export extra args for test scripts to use
export SMAK_EXTRA_ARGS

# Monitor a process and kill it if log file stops growing or gets too large
# Usage: monitor_process PID LOG_FILE MAX_IDLE_SECONDS MAX_LOG_SIZE_MB
monitor_process() {
    local pid=$1
    local log_file=$2
    local max_idle=${3:-30}        # Default 30 seconds of no activity
    local max_size_mb=${4:-100}    # Default 100MB max log size
    local max_size=$((max_size_mb * 1024 * 1024))

    local last_size=0
    local idle_time=0
    local check_interval=2  # Check every 2 seconds

    while kill -0 "$pid" 2>/dev/null; do
        sleep "$check_interval"

        if [ -f "$log_file" ]; then
            local current_size=$(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo 0)

            # Check if log is too large
            if [ "$current_size" -gt "$max_size" ]; then
                echo "WARNING: Log file $log_file exceeded ${max_size_mb}MB, killing test (PID $pid)" >&2
                kill -TERM "$pid" 2>/dev/null
                sleep 1
                kill -KILL "$pid" 2>/dev/null
                return 124  # Same exit code as timeout
            fi

            # Check if log file is growing
            if [ "$current_size" -gt "$last_size" ]; then
                # Log is growing, reset idle timer
                last_size=$current_size
                idle_time=0
            else
                # Log hasn't grown
                idle_time=$((idle_time + check_interval))
                if [ "$idle_time" -ge "$max_idle" ]; then
                    echo "WARNING: Log file $log_file idle for ${max_idle}s, killing test (PID $pid)" >&2
                    kill -TERM "$pid" 2>/dev/null
                    sleep 1
                    kill -KILL "$pid" 2>/dev/null
                    return 124  # Same exit code as timeout
                fi
            fi
        fi
    done

    # Process finished naturally
    wait "$pid"
    return $?
}

# Handle clone mode
if [ -n "$CLONE_MODE" ]; then
    # Generate tag from current timestamp
    TAG=$(date +%Y%m%d-%H%M%S)
    TEST_DIR="/tmp/smak/test-${TAG}"

    echo "======================================"
    echo "CLONE MODE: Setting up test environment"
    echo "======================================"
    echo "Test directory: $TEST_DIR"
    echo ""

    # Create test directory
    mkdir -p "$TEST_DIR"

    if [ "$CLONE_MODE" = "local" ]; then
        echo "Cloning from local repository..."
        # Get the repository root (parent of test directory)
        REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
        git clone "$REPO_ROOT" "$TEST_DIR" || {
            echo "Error: Failed to clone repository"
            exit 1
        }
    elif [ "$CLONE_MODE" = "query" ]; then
        echo "Available branches:"
        echo "  1) Current branch: $(git -C "$SCRIPT_DIR/.." branch --show-current)"
        echo "  2) main"
        echo ""
        read -p "Select branch (1 or 2): " choice

        REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

        if [ "$choice" = "1" ]; then
            BRANCH=$(git -C "$REPO_ROOT" branch --show-current)
            echo "Cloning branch: $BRANCH"
            git clone -b "$BRANCH" "$REPO_ROOT" "$TEST_DIR" || {
                echo "Error: Failed to clone repository"
                exit 1
            }
        elif [ "$choice" = "2" ]; then
            echo "Cloning branch: main"
            git clone -b main "$REPO_ROOT" "$TEST_DIR" || {
                echo "Error: Failed to clone repository"
                exit 1
            }
        else
            echo "Invalid choice"
            exit 1
        fi
    fi

    echo ""
    echo "Clone complete. Running tests in $TEST_DIR/test"
    echo ""

    # Change to test directory and re-run this script without clone option
    cd "$TEST_DIR/test"

    # Build the command to run, preserving other options
    CMD="./run-regression"
    [ $SANITY_MODE -eq 1 ] && CMD="$CMD --sanity"
    [ $FULL_MODE -eq 1 ] && CMD="$CMD --full"
    [ $VERBOSE -eq 1 ] && CMD="$CMD --verbose"
    [ $TTY_MODE -eq 1 ] && CMD="$CMD --tty"
    [ $NO_PARALLEL -eq 1 ] && CMD="$CMD --no-parallel"
    [ $FAST_MODE -eq 1 ] && CMD="$CMD --fast"

    # Run the tests
    $CMD
    EXIT_CODE=$?

    echo ""
    echo "======================================"
    echo "Test directory preserved at: $TEST_DIR"
    echo "======================================"

    exit $EXIT_CODE
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Counters
TOTAL=0
PASSED=0
FAILED=0
SKIPPED=0

# Test results
declare -a FAILED_TESTS
declare -a PASSED_TESTS

# Function to show partial report and cleanup on interrupt
show_partial_report() {
    echo ""
    echo ""
    echo "======================================"
    echo "INTERRUPTED - PARTIAL TEST SUMMARY"
    echo "======================================"
    echo "Total tests:   $TOTAL"
    echo -e "Passed:        ${GREEN}$PASSED${NC}"
    echo -e "Failed:        ${RED}$FAILED${NC}"
    echo -e "Skipped:       ${YELLOW}$SKIPPED${NC}"

    if [ $FAILED -gt 0 ]; then
        echo ""
        echo "Failed tests:"
        for test in "${FAILED_TESTS[@]}"; do
            echo -e "  ${RED}✗${NC} $test"
        done
    fi

    echo ""
    echo "Testing interrupted by user (Ctrl-C)"
    echo ""

    # Clean up any temp files from interrupted test
    rm -f /tmp/smak-wrapper-*.sh 2>/dev/null
    rm -f /tmp/smak-test-*.log 2>/dev/null

    exit 130  # Standard exit code for SIGINT
}

# Set up Ctrl-C and termination handlers
trap show_partial_report SIGINT SIGTERM

echo "======================================"
if [ $SANITY_MODE -eq 1 ]; then
    echo "SMAK SANITY CHECK (Quick Tests)"
else
    echo "SMAK REGRESSION TEST SUITE"
fi
echo "======================================"
echo ""
if [ $NO_PARALLEL -eq 1 ]; then
    echo "Test modes: [Seq/NoCache+fail] [Seq/Cache+fail]"
    echo "Results shown as: PpPp (all pass + fail tests work in both modes)"
    echo "              or: PxPx (all pass, no fail test)"
    echo "              or: PpFp (2nd mode failed, fail tests work), etc."
else
    echo "Test modes: [Seq/NoCache+fail] [Seq/Cache+fail] [Par/NoCache+fail] [Par/Cache+fail]"
    echo "Results shown as: PpPpPpPp (all pass + fail tests work in all modes)"
    echo "              or: PxPxPxPx (all pass, no fail test)"
    echo "              or: PpFpPpPp (2nd mode failed, fail tests work), etc."
fi
echo "  P=pass, F=fail, T=timeout"
echo "  p=-fail test passed (correctly failed), f=-fail test failed (wrongly succeeded), t=-fail timeout, x=no -fail test"
if [ $FAST_MODE -eq 1 ]; then
    echo "  -=skipped (fast mode, previous failure)"
fi
echo ""

# Function to run a test script
run_test() {
    local test_script="$1"
    local test_name=$(basename "$test_script" .sh)

    ((TOTAL++))

    printf "Running %-40s ... " "$test_name"

    if [ ! -x "$test_script" ]; then
        echo -e "${YELLOW}SKIP${NC} (not executable)"
        ((SKIPPED++))
        return
    fi

    # Check if test uses interactive debug mode (-Kd flag)
    # These tests need PTY automation to work properly
    local is_interactive=0
    if grep -q "smak.*-Kd" "$test_script" 2>/dev/null; then
        is_interactive=1
    fi

    # Check if there's a script file for this test
    local script_file_path="scripts/${test_name}.script"
    local has_script=0
    local temp_script_file=""
    unset script_file

    if [ -f "$script_file_path" ]; then
        has_script=1
	script_file=$script_file_path
    elif [ $is_interactive -eq 1 ] && [ $TTY_MODE -eq 0 ]; then
        # For interactive tests without script file, extract commands from heredoc
        # Look for heredoc pattern: cat <<EOF | ../smak -Kd
        if grep -q "cat.*<<.*|.*smak.*-Kd" "$test_script" 2>/dev/null; then
            # Extract commands from heredoc (between <<EOF and EOF)
            temp_script_file="/tmp/smak-script-${test_name}-$$.script"
            sed -n '/cat.*<<.*|.*smak.*-Kd/,/^EOF$/p' "$test_script" | \
                sed '1d;$d' > "$temp_script_file"
            script_file="$temp_script_file"
            has_script=2
        fi
    fi

    # Interactive tests in --tty mode will run with user input
    # Otherwise use script runner for automation

    # Run test and capture output for all 4 modes
    local output_seq_nocache output_seq_cache output_par_nocache output_par_cache
    local result_seq_nocache result_seq_cache result_par_nocache result_par_cache
    local start_time=$(date +%s)

    # Verbose mode shows output but still uses proper handling
    local show_output=$VERBOSE

    if [ $show_output -eq 1 ]; then
        echo ""
    fi

    # Helper function to run a single mode
    run_single_mode() {
        local mode_cache="$1"  # "off" or "default"
        local mode_jobs="$2"   # "" (sequential) or "-j4" (parallel)
        local output_file="$3"  # temp file to store output

        if [ $is_interactive -eq 1 ] && [ $has_script -ne 0 ] && [ $TTY_MODE -eq 0 ]; then
            # Extract smak arguments from test script (e.g., -f Makefile.test)
            local smak_args=$(grep -oP '(?<=smak ).*(?=-Kd)' "$test_script" | head -1)

            # Create wrapper script that execs smak directly with jobs arg
            local wrapper_script="/tmp/smak-wrapper-${test_name}-$$.sh"
            cat > "$wrapper_script" << WRAPPER_EOF
#!/bin/bash
cd "$SCRIPT_DIR"
exec ../smak $smak_args $mode_jobs $SMAK_EXTRA_ARGS -Kd
WRAPPER_EOF
            chmod +x "$wrapper_script"

            # Run with script automation using run-with-script.pl (monitor log instead of timeout)
            env SMAK_CACHE_DIR=$mode_cache ./run-with-script.pl "$script_file" "$wrapper_script" >"$output_file" 2>&1 &

            local pid=$!
            monitor_process "$pid" "$output_file" 30 100
            local result=$?
            rm -f "$wrapper_script"
            return $result

        elif [ $is_interactive -eq 1 ] && [ $TTY_MODE -eq 1 ]; then
            # For TTY mode, we can't easily inject -j, skip parallel testing
            if [ -n "$mode_jobs" ]; then
                return 0  # Skip parallel in TTY mode
            fi
            env SMAK_CACHE_DIR=$mode_cache ./"$test_script" >"$output_file" 2>&1 &
            local pid=$!
            monitor_process "$pid" "$output_file" 60 100
            return $?

        else
            # Default: non-interactive tests, redirect stdin (monitor log instead of timeout)
            # For parallel mode, modify the test script invocation
            if [ -n "$mode_jobs" ] || [ -n "$SMAK_EXTRA_ARGS" ]; then
                # Inject -j4 and extra args into smak invocation (handles both $SMAK variable and literal 'smak')
                local inject_args="$mode_jobs $SMAK_EXTRA_ARGS"
                env SMAK_CACHE_DIR=$mode_cache bash -c "sed 's/\(\\\$SMAK\|smak\)\( \|$\)/\1 $inject_args\2/' '$test_script' | bash" >"$output_file" 2>&1 < "${script_file:-/dev/null}" &
            else
                env SMAK_CACHE_DIR=$mode_cache ./"$test_script" >"$output_file" 2>&1 < "${script_file:-/dev/null}" &
            fi
            local pid=$!
            monitor_process "$pid" "$output_file" 30 100
            return $?
        fi
    }

    # Create temp files for output
    local out_seq_nc="/tmp/smak-test-${test_name}-seq-nc-$$.log"
    local out_seq_c="/tmp/smak-test-${test_name}-seq-c-$$.log"
    local out_par_nc="/tmp/smak-test-${test_name}-par-nc-$$.log"
    local out_par_c="/tmp/smak-test-${test_name}-par-c-$$.log"

    # Check if fail test exists
    local fail_test="${test_script%.sh}-fail.sh"
    local has_fail_test=0
    local is_fail_interactive=0
    local fail_script_file=""
    if [ -f "$fail_test" ] && [ -x "$fail_test" ]; then
        has_fail_test=1
        # Check if fail test is also interactive
        if grep -q "smak.*-Kd" "$fail_test" 2>/dev/null; then
            is_fail_interactive=1
            # Check for corresponding script file
            local fail_script_path="scripts/${test_name}-fail.script"
            if [ -f "$fail_script_path" ]; then
                fail_script_file="$fail_script_path"
            fi
        fi
    fi

    # Helper to run fail test with appropriate automation
    run_fail_test() {
        local mode_cache="$1"
        local mode_jobs="$2"
        local fail_out="$3"

        if [ $is_fail_interactive -eq 1 ] && [ -n "$fail_script_file" ] && [ $TTY_MODE -eq 0 ]; then
            # Use PTY automation for interactive fail tests
            local smak_args=$(grep -oP '(?<=smak ).*(?=-Kd)' "$fail_test" | head -1)
            local wrapper_script="/tmp/smak-fail-wrapper-${test_name}-$$.sh"
            cat > "$wrapper_script" << WRAPPER_EOF
#!/bin/bash
cd "$SCRIPT_DIR"
exec ../smak $smak_args $mode_jobs $SMAK_EXTRA_ARGS -Kd
WRAPPER_EOF
            chmod +x "$wrapper_script"
            env SMAK_CACHE_DIR=$mode_cache ./run-with-script.pl "$fail_script_file" "$wrapper_script" >"$fail_out" 2>&1 &
            local pid=$!
            monitor_process "$pid" "$fail_out" 30 100
            local result=$?
            rm -f "$wrapper_script"
            return $result
        else
            # Run fail test directly
            env SMAK_CACHE_DIR=$mode_cache ./"$(basename "$fail_test")" >"$fail_out" 2>&1 < /dev/null &
            local pid=$!
            monitor_process "$pid" "$fail_out" 30 100
            return $?
        fi
    }

    # Run all 4 modes (and -fail tests if they exist)
    # Track whether we should skip remaining modes (for --fast)
    local skip_remaining=0

    # Mode 1: Sequential + NoCache
    run_single_mode "off" "" "$out_seq_nc"
    result_seq_nocache=$?
    local result_seq_nocache_fail=0
    if [ $result_seq_nocache -eq 124 ]; then
        echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
        ((FAILED++))
        [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
        return
    fi
    if [ $has_fail_test -eq 1 ]; then
        local fail_out="/tmp/smak-test-${test_name}-seq-nc-fail-$$.log"
        run_fail_test "off" "" "$fail_out"
        result_seq_nocache_fail=$?
        rm -f "$fail_out"
    fi

    # Check if we should skip remaining modes in fast mode
    if [ $FAST_MODE -eq 1 ] && [ $result_seq_nocache -ne 0 ]; then
        skip_remaining=1
    fi
    if [ $FAST_MODE -eq 1 ] && [ $has_fail_test -eq 1 ] && [ $result_seq_nocache_fail -eq 0 ]; then
        skip_remaining=1
    fi

    # Mode 2: Sequential + Cache
    if [ $skip_remaining -eq 0 ]; then
        run_single_mode "default" "" "$out_seq_c"
        result_seq_cache=$?
        local result_seq_cache_fail=0
        if [ $result_seq_cache -eq 124 ]; then
            echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
            ((FAILED++))
            [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
            rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
            return
        fi
        if [ $has_fail_test -eq 1 ]; then
            local fail_out="/tmp/smak-test-${test_name}-seq-c-fail-$$.log"
            run_fail_test "default" "" "$fail_out"
            result_seq_cache_fail=$?
            rm -f "$fail_out"
        fi

        # Check if we should skip remaining modes in fast mode
        if [ $FAST_MODE -eq 1 ] && [ $result_seq_cache -ne 0 ]; then
            skip_remaining=1
        fi
        if [ $FAST_MODE -eq 1 ] && [ $has_fail_test -eq 1 ] && [ $result_seq_cache_fail -eq 0 ]; then
            skip_remaining=1
        fi
    else
        result_seq_cache=-2  # Special marker for skipped
        local result_seq_cache_fail=-2
    fi

    # Mode 3: Parallel + NoCache
    if [ $NO_PARALLEL -eq 1 ] || [ $skip_remaining -eq 1 ]; then
        result_par_nocache=-2  # Special marker for skipped
        local result_par_nocache_fail=-2
    else
        run_single_mode "off" "-j4" "$out_par_nc"
        result_par_nocache=$?
        local result_par_nocache_fail=0
        if [ $result_par_nocache -eq 124 ]; then
            echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
            ((FAILED++))
            [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
            rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
            return
        fi
        if [ $has_fail_test -eq 1 ]; then
            local fail_out="/tmp/smak-test-${test_name}-par-nc-fail-$$.log"
            run_fail_test "off" "-j4" "$fail_out"
            result_par_nocache_fail=$?
            rm -f "$fail_out"
        fi

        # Check if we should skip remaining modes in fast mode
        if [ $FAST_MODE -eq 1 ] && [ $result_par_nocache -ne 0 ]; then
            skip_remaining=1
        fi
        if [ $FAST_MODE -eq 1 ] && [ $has_fail_test -eq 1 ] && [ $result_par_nocache_fail -eq 0 ]; then
            skip_remaining=1
        fi
    fi

    # Mode 4: Parallel + Cache
    if [ $NO_PARALLEL -eq 1 ] || [ $skip_remaining -eq 1 ]; then
        result_par_cache=-2  # Special marker for skipped
        local result_par_cache_fail=-2
    else
        run_single_mode "default" "-j4" "$out_par_c"
        result_par_cache=$?
        local result_par_cache_fail=0
        if [ $result_par_cache -eq 124 ]; then
            echo -e "${RED}TIMEOUT${NC} (killed after 30s)"
            ((FAILED++))
            [ -n "$temp_script_file" ] && rm -f "$temp_script_file"
            rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
            return
        fi
        if [ $has_fail_test -eq 1 ]; then
            local fail_out="/tmp/smak-test-${test_name}-par-c-fail-$$.log"
            run_fail_test "default" "-j4" "$fail_out"
            result_par_cache_fail=$?
            rm -f "$fail_out"
        fi
    fi

    # Clean up temp script file
    [ -n "$temp_script_file" ] && rm -f "$temp_script_file"

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Display output in verbose mode
    if [ $show_output -eq 1 ]; then
        echo "=== Sequential/NoCache ==="
        cat "$out_seq_nc"
        echo ""
        echo "=== Sequential/Cache ==="
        cat "$out_seq_c"
        echo ""
        echo "=== Parallel/NoCache ==="
        cat "$out_par_nc"
        echo ""
        echo "=== Parallel/Cache ==="
        cat "$out_par_c"
        echo ""
    fi

    # Build result string (PpPpPpPp or PxPxPxPx etc.)
    # Legend: P=pass, F=fail, T=timeout
    #         p=-fail test passed (correctly failed), f=-fail test failed (wrongly succeeded), t=-fail test timeout
    #         x=no -fail test
    local result_str=""
    local all_passed=1

    # Mode 1: Sequential + NoCache
    if [ $result_seq_nocache -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $result_seq_nocache -eq 0 ]; then
        result_str="${result_str}P"
    elif [ $result_seq_nocache -eq 124 ]; then
        result_str="${result_str}T"
        all_passed=0
    else
        result_str="${result_str}F"
        all_passed=0
    fi
    if [ $result_seq_nocache_fail -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $has_fail_test -eq 1 ]; then
        if [ $result_seq_nocache_fail -ne 0 ] && [ $result_seq_nocache_fail -ne 124 ]; then
            result_str="${result_str}p"
        elif [ $result_seq_nocache_fail -eq 124 ]; then
            result_str="${result_str}t"
            all_passed=0
        else
            result_str="${result_str}f"
            all_passed=0
        fi
    else
        result_str="${result_str}x"
    fi

    # Mode 2: Sequential + Cache
    if [ $result_seq_cache -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $result_seq_cache -eq 0 ]; then
        result_str="${result_str}P"
    elif [ $result_seq_cache -eq 124 ]; then
        result_str="${result_str}T"
        all_passed=0
    else
        result_str="${result_str}F"
        all_passed=0
    fi
    if [ $result_seq_cache_fail -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $has_fail_test -eq 1 ]; then
        if [ $result_seq_cache_fail -ne 0 ] && [ $result_seq_cache_fail -ne 124 ]; then
            result_str="${result_str}p"
        elif [ $result_seq_cache_fail -eq 124 ]; then
            result_str="${result_str}t"
            all_passed=0
        else
            result_str="${result_str}f"
            all_passed=0
        fi
    else
        result_str="${result_str}x"
    fi

    # Mode 3: Parallel + NoCache
    if [ $result_par_nocache -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $result_par_nocache -eq 0 ]; then
        result_str="${result_str}P"
    elif [ $result_par_nocache -eq 124 ]; then
        result_str="${result_str}T"
        all_passed=0
    else
        result_str="${result_str}F"
        all_passed=0
    fi
    if [ $result_par_nocache_fail -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $has_fail_test -eq 1 ]; then
        if [ $result_par_nocache_fail -ne 0 ] && [ $result_par_nocache_fail -ne 124 ]; then
            result_str="${result_str}p"
        elif [ $result_par_nocache_fail -eq 124 ]; then
            result_str="${result_str}t"
            all_passed=0
        else
            result_str="${result_str}f"
            all_passed=0
        fi
    else
        result_str="${result_str}x"
    fi

    # Mode 4: Parallel + Cache
    if [ $result_par_cache -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $result_par_cache -eq 0 ]; then
        result_str="${result_str}P"
    elif [ $result_par_cache -eq 124 ]; then
        result_str="${result_str}T"
        all_passed=0
    else
        result_str="${result_str}F"
        all_passed=0
    fi
    if [ $result_par_cache_fail -eq -2 ]; then
        result_str="${result_str}-"
    elif [ $has_fail_test -eq 1 ]; then
        if [ $result_par_cache_fail -ne 0 ] && [ $result_par_cache_fail -ne 124 ]; then
            result_str="${result_str}p"
        elif [ $result_par_cache_fail -eq 124 ]; then
            result_str="${result_str}t"
            all_passed=0
        else
            result_str="${result_str}f"
            all_passed=0
        fi
    else
        result_str="${result_str}x"
    fi

    # Display result
    if [ $all_passed -eq 1 ]; then
        echo -e "${GREEN}${result_str}${NC} (${duration}s)"
        ((PASSED++))
        PASSED_TESTS+=("$test_name")
        # Clean up temp files on success
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
    else
        echo -e "${RED}${result_str}${NC} (${duration}s)"
        ((FAILED++))
        FAILED_TESTS+=("$test_name")
        # Save failure details
        if [ $VERBOSE -eq 0 ]; then
            local fail_log="/tmp/smak-test-fail-$test_name.log"
            {
                echo "Test: $test_name"
                echo "Results: Seq/NoCache=$result_seq_nocache Seq/Cache=$result_seq_cache Par/NoCache=$result_par_nocache Par/Cache=$result_par_cache"
                if [ $has_fail_test -eq 1 ]; then
                    echo "Fail test results: Seq/NoCache=$result_seq_nocache_fail Seq/Cache=$result_seq_cache_fail Par/NoCache=$result_par_nocache_fail Par/Cache=$result_par_cache_fail"
                fi
                echo "Result string: $result_str"
                echo ""
                echo "=== Sequential/NoCache Output ==="
                cat "$out_seq_nc"
                echo ""
                echo "=== Sequential/Cache Output ==="
                cat "$out_seq_c"
                echo ""
                echo "=== Parallel/NoCache Output ==="
                cat "$out_par_nc"
                echo ""
                echo "=== Parallel/Cache Output ==="
                cat "$out_par_c"
            } > "$fail_log"
        fi
        # Clean up temp files after saving to fail log
        rm -f "$out_seq_nc" "$out_seq_c" "$out_par_nc" "$out_par_c"
    fi
}

# Define sanity test list (quick, basic non-interactive tests)
# Note: Interactive tests currently timeout due to select() issue with STDIN
SANITY_TESTS=(
    "test_phony_repeat.sh"
)
SANITY_DEFAULT_TARGET_TEST="test-default-target.sh"

# Collect all tests into an array
TESTS_TO_RUN=()

if [ $SANITY_MODE -eq 1 ]; then
    # Sanity mode: only selected tests
    for test in "${SANITY_TESTS[@]}"; do
        if [ -f "$test" ]; then
            TESTS_TO_RUN+=("$test")
        fi
    done
    if [ -f "$SANITY_DEFAULT_TARGET_TEST" ]; then
        TESTS_TO_RUN+=("$SANITY_DEFAULT_TARGET_TEST")
    fi
else
    # Normal mode: all unit tests
    for test in test_*.sh; do
        # Skip -fail.sh tests (they're run as variants of the main test)
        if [[ "$test" == *"-fail.sh" ]]; then
            continue
        fi
        if [ -f "$test" ]; then
            TESTS_TO_RUN+=("$test")
        fi
    done
    # Add default target test
    if [ -f "test-default-target.sh" ]; then
        TESTS_TO_RUN+=("test-default-target.sh")
    fi
fi

# Apply filter if specified
if [ -n "$FILTER_PATTERN" ]; then
    FILTERED_TESTS=()
    for test in "${TESTS_TO_RUN[@]}"; do
        if echo "$test" | grep -qE "$FILTER_PATTERN"; then
            FILTERED_TESTS+=("$test")
        fi
    done
    TESTS_TO_RUN=("${FILTERED_TESTS[@]}")
fi

# If list mode, just print tests and exit
if [ $LIST_MODE -eq 1 ]; then
    echo "Tests that would be run:"
    echo ""
    for test in "${TESTS_TO_RUN[@]}"; do
        echo "  - $test"
    done
    echo ""
    echo "Total: ${#TESTS_TO_RUN[@]} tests"
    if [ $FULL_MODE -eq 1 ]; then
        echo ""
        echo "Additional tests (full mode):"
        echo "  - Random build tests (run-tests)"
    fi
    exit 0
fi

# Run all collected tests
echo "Unit Tests:"
echo "----------"

if [ $PARALLEL_JOBS -gt 1 ]; then
    # Parallel execution mode
    declare -a test_results=()

    # Process tests in batches
    idx=0
    total_tests=${#TESTS_TO_RUN[@]}

    while [ $idx -lt $total_tests ]; do
        # Launch a batch of up to PARALLEL_JOBS tests
        batch_pids=()
        batch_end=$((idx + PARALLEL_JOBS))
        if [ $batch_end -gt $total_tests ]; then
            batch_end=$total_tests
        fi

        while [ $idx -lt $batch_end ]; do
            test="${TESTS_TO_RUN[$idx]}"
            result_file="/tmp/smak-regtest-$$-$(basename "$test" .sh).result"
            test_results+=("$result_file")

            (
                # Redirect stdout/stderr to result file, stdin from /dev/null
                exec > "$result_file" 2>&1 < /dev/null
                run_test "$test"
                echo "EXIT_CODE=$?"
            ) &
            batch_pids+=($!)
            ((idx++))
        done

        # Wait for this batch to complete
        for pid in "${batch_pids[@]}"; do
            wait $pid
        done
    done

    # Now display results in original order and collect counters
    idx=0
    for test in "${TESTS_TO_RUN[@]}"; do
        # Separate default target test into its own section
        if [ "$test" = "test-default-target.sh" ]; then
            echo ""
            echo "Default Target Tests:"
            echo "--------------------"
        fi

        result_file="${test_results[$idx]}"
        if [ -f "$result_file" ]; then
            # Extract and display the output
            result_output=$(grep -v "^EXIT_CODE=" "$result_file" || true)
            echo "$result_output"

            # Count this test
            ((TOTAL++))

            # Check if test passed or failed based on output
            # Look for color codes: GREEN='\033[0;32m' RED='\033[0;31m' YELLOW='\033[1;33m'
            if echo "$result_output" | grep -q "\[0;32m"; then
                ((PASSED++))
                PASSED_TESTS+=("$(basename "$test" .sh)")
            elif echo "$result_output" | grep -q "SKIP"; then
                ((SKIPPED++))
            elif echo "$result_output" | grep -q "\[0;31m"; then
                ((FAILED++))
                FAILED_TESTS+=("$(basename "$test" .sh)")
            fi

            rm -f "$result_file"
        fi
        ((idx++))
    done
else
    # Sequential execution mode (original behavior)
    for test in "${TESTS_TO_RUN[@]}"; do
        # Separate default target test into its own section
        if [ "$test" = "test-default-target.sh" ]; then
            echo ""
            echo "Default Target Tests:"
            echo "--------------------"
        fi
        run_test "$test"
    done
fi

# Run generator-based tests if in full mode
if [ $FULL_MODE -eq 1 ]; then
    echo ""
    echo "Random Build Tests:"
    echo "------------------"
    echo "(Running 10 iterations, may take 1-2 minutes...)"

    if [ -x "./run-tests" ]; then
        # Run test-generator tests
        if [ $VERBOSE -eq 1 ]; then
            ./run-tests -f 5 -t 60 -v
            gen_result=$?
        else
            ./run-tests -f 5 -t 60 > /tmp/smak-generator-test.log 2>&1
            gen_result=$?
        fi

        if [ $gen_result -eq 0 ]; then
            echo -e "Random builds:                            ${GREEN}PASS${NC}"
            ((PASSED++))
            ((TOTAL++))
        else
            echo -e "Random builds:                            ${RED}FAIL${NC}"
            ((FAILED++))
            ((TOTAL++))
            FAILED_TESTS+=("random-builds")
        fi
    else
        echo -e "run-tests not found:                      ${YELLOW}SKIP${NC}"
        ((SKIPPED++))
        ((TOTAL++))
    fi
fi

# Run CLI tests if in full mode
if [ $FULL_MODE -eq 1 ]; then
    echo ""
    echo "CLI Tests:"
    echo "---------"

    if [ -x "./test-cli-advanced" ]; then
        if [ $VERBOSE -eq 1 ]; then
            ./test-cli-advanced
            cli_result=$?
        else
            ./test-cli-advanced > /tmp/smak-cli-test.log 2>&1
            cli_result=$?
        fi

        if [ $cli_result -eq 0 ]; then
            echo -e "Advanced CLI tests:                       ${GREEN}PASS${NC}"
            ((PASSED++))
            ((TOTAL++))
        else
            echo -e "Advanced CLI tests:                       ${RED}FAIL${NC}"
            ((FAILED++))
            ((TOTAL++))
            FAILED_TESTS+=("cli-tests")
        fi
    else
        echo -e "test-cli-advanced not found:              ${YELLOW}SKIP${NC}"
        ((SKIPPED++))
        ((TOTAL++))
    fi
fi

# Summary
echo ""
echo "======================================"
echo "TEST SUMMARY"
echo "======================================"
echo "Total tests:   $TOTAL"
echo -e "Passed:        ${GREEN}$PASSED${NC}"
echo -e "Failed:        ${RED}$FAILED${NC}"
echo -e "Skipped:       ${YELLOW}$SKIPPED${NC}"

if [ $FAILED -gt 0 ]; then
    echo ""
    echo "Failed tests:"
    for test in "${FAILED_TESTS[@]}"; do
        echo -e "  ${RED}✗${NC} $test"
        if [ -f "/tmp/smak-test-fail-$test.log" ]; then
            echo "     Log: /tmp/smak-test-fail-$test.log"
        fi
    done
    echo ""
    echo "Tip: Run with --verbose to see test output"
fi

echo ""
if [ $FAILED -eq 0 ]; then
    echo -e "${GREEN}All tests passed!${NC}"
    if [ $SANITY_MODE -eq 1 ]; then
        echo ""
        echo "Note: This was a sanity check (2 basic non-interactive tests)."
        echo "Run '$0' for full regression testing."
        echo "Run '$0 --full' for comprehensive testing including random builds and CLI tests."
    elif [ $FULL_MODE -eq 0 ]; then
        echo ""
        echo "Note: This was a quick regression test."
        echo "Run '$0 --full' for comprehensive testing including:"
        echo "  - Random build tests (test-generator)"
        echo "  - CLI interaction tests"
    fi
    exit 0
else
    echo -e "${RED}Some tests failed.${NC}"
    exit 1
fi
