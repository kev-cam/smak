#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket::INET;
use IO::Select;
use Cwd 'abs_path';

# Find smak-jobserver processes using /proc
sub find_jobservers {
    my @jobservers;

    # Scan /proc for smak-jobserver processes
    opendir(my $proc_dir, '/proc') or die "Cannot open /proc: $!\n";
    my @pids = grep { /^\d+$/ } readdir($proc_dir);
    closedir($proc_dir);

    for my $pid (@pids) {
        my $cmdline_file = "/proc/$pid/cmdline";
        next unless -f $cmdline_file;

        open(my $fh, '<', $cmdline_file) or next;
        my $cmdline = <$fh>;
        close($fh);
        next unless $cmdline;

        $cmdline =~ s/\0/ /g;
        $cmdline =~ s/\s+$//;

        # Check if it's a smak-jobserver process
        if ($cmdline =~ /smak-jobserver\s+(\d+)/) {
            my $num_workers = $1;

            # Get working directory
            my $cwd = readlink("/proc/$pid/cwd");

            # Get listening ports using lsof
            my @ports;
            my $lsof_output = `lsof -Pan -p $pid -i TCP -s TCP:LISTEN 2>/dev/null`;
            for my $line (split /\n/, $lsof_output) {
                if ($line =~ /:(\d+)\s+\(LISTEN\)/) {
                    push @ports, $1;
                }
            }

            # Expect 3 ports: master, worker, observer
            if (@ports >= 2) {
                push @jobservers, {
                    pid => $pid,
                    workers => $num_workers,
                    cwd => $cwd,
                    ports => \@ports,
                    cmdline => $cmdline,
                };
            }
        }
    }

    return @jobservers;
}

# Verify and update port files
sub check_port_files {
    my (@jobservers) = @_;

    # Get existing port files
    my @port_files = glob("/tmp/smak-jobserver-*.port");

    # Build hash of valid PIDs
    my %valid_pids = map { $_->{pid} => 1 } @jobservers;

    # Clean up stale port files
    for my $file (@port_files) {
        my ($pid) = $file =~ /smak-jobserver-(\d+)\.port/;
        unless ($pid && $valid_pids{$pid}) {
            print STDERR "Removing stale port file: $file\n";
            unlink $file;
        }
    }

    # Verify port files are consistent
    for my $js (@jobservers) {
        my $port_file = "/tmp/smak-jobserver-$js->{pid}.port";
        if (-f $port_file) {
            # Read and verify
            open(my $fh, '<', $port_file) or next;
            my @file_ports;
            while (my $line = <$fh>) {
                chomp $line;
                push @file_ports, $line if $line =~ /^\d+$/;
            }
            close($fh);

            # Check if ports match (at least observer and master)
            if (@file_ports >= 2) {
                $js->{observer_port} = $file_ports[0];
                $js->{master_port} = $file_ports[1];
            }
        }
    }
}

# Find running job-master instances
my @jobservers = find_jobservers();

unless (@jobservers) {
    print STDERR "No running smak job-master instances found.\n";
    print STDERR "Checking for smak.pl processes...\n";

    my $smak_procs = `pgrep -lfa 'smak.pl' 2>/dev/null`;
    if ($smak_procs) {
        print STDERR "Found smak.pl processes:\n$smak_procs";
        print STDERR "\nThe job-master may have crashed. Check for errors in:\n";
        print STDERR "  - stderr output from smak.pl\n";
        print STDERR "  - Try running: SMAK_DEBUG=1 smak.pl -cli -j 4\n";
    }

    exit 1;
}

# Clean up stale port files and verify consistency
check_port_files(@jobservers);

my $selected_js;

if (@jobservers > 1) {
    print "Multiple smak instances found:\n";
    for (my $i = 0; $i < @jobservers; $i++) {
        my $js = $jobservers[$i];
        print "  [$i] PID $js->{pid}";
        print " - $js->{cwd}" if $js->{cwd};
        print "\n";
        print "      Workers: $js->{workers}";
        if ($js->{master_port}) {
            print ", Master port: $js->{master_port}";
        }
        print "\n";
    }
    print "Select instance (0-" . ($#jobservers) . "): ";
    my $choice = <STDIN>;
    chomp $choice;
    if ($choice =~ /^\d+$/ && $choice <= $#jobservers) {
        $selected_js = $jobservers[$choice];
    } else {
        die "Invalid selection\n";
    }
} else {
    $selected_js = $jobservers[0];
}

my $jobserver_pid = $selected_js->{pid};
my $master_port = $selected_js->{master_port};
my $observer_port = $selected_js->{observer_port};

# Prefer master port for CLI mode, fall back to observer
my $port = $master_port || $observer_port;
unless ($port) {
    die "Cannot determine port for job-master (PID $jobserver_pid)\n";
}

print "Connecting to job-master (PID $jobserver_pid) on port $port...\n";

# Connect to observer socket
my $socket = IO::Socket::INET->new(
    PeerHost => '127.0.0.1',
    PeerPort => $port,
    Proto    => 'tcp',
    Timeout  => 5,
) or die "Cannot connect to job-master: $!\n";

$socket->autoflush(1);
print "Connected to job-master observer.\n";
print "Commands: [s]tatus, [q]uit, [h]elp\n\n";

# Set up select for non-blocking I/O
my $select = IO::Select->new($socket, \*STDIN);

# Request initial status
print $socket "STATUS\n";

my $in_status = 0;

while (1) {
    my @ready = $select->can_read(0.1);

    for my $handle (@ready) {
        if ($handle == $socket) {
            # Message from job-master
            my $line = <$socket>;
            unless (defined $line) {
                print "\nJob-master disconnected.\n";
                exit 0;
            }
            chomp $line;

            if ($line eq 'STATUS_START') {
                $in_status = 1;
                print "\n=== Build Status ===\n";

            } elsif ($line eq 'STATUS_END') {
                $in_status = 0;
                print "==================\n";
                print "smak-attach> ";
                STDOUT->flush();

            } elsif ($line =~ /^QUEUED (\d+)$/) {
                print "Queued jobs: $1\n";

            } elsif ($line =~ /^RUNNING (\d+)$/) {
                print "Running jobs: $1\n";

            } elsif ($line =~ /^WORKERS (\d+)$/) {
                print "Total workers: $1\n\n";

            } elsif ($line =~ /^QUEUE_ITEM (.*)$/) {
                print "  [Queued] $1\n";

            } elsif ($line =~ /^RUNNING_ITEM (\d+) (\w+) (.*)$/) {
                my ($task_id, $state, $target) = ($1, $2, $3);
                print "  [$state] Task $task_id: $target\n";

            } elsif ($line =~ /^WORKER_STATUS (\w+) (\d+)$/) {
                my ($status, $task_id) = ($1, $2);
                if ($status eq 'READY') {
                    print "  Worker: READY (idle)\n";
                } else {
                    print "  Worker: BUSY (task $task_id)\n";
                }

            } elsif ($line =~ /^QUEUED (.*)$/) {
                print "[Queued] $1\n";

            } else {
                print "$line\n" if $line;
            }

        } elsif ($handle == \*STDIN) {
            # User input
            my $input = <STDIN>;
            unless (defined $input) {
                print "\nExiting...\n";
                print $socket "QUIT\n";
                exit 0;
            }
            chomp $input;

            if ($input =~ /^s(tatus)?$/i) {
                print $socket "STATUS\n";

            } elsif ($input =~ /^q(uit)?$/i) {
                print "Disconnecting...\n";
                print $socket "QUIT\n";
                exit 0;

            } elsif ($input =~ /^h(elp)?$/i) {
                print "\nCommands:\n";
                print "  s, status - Request current build status\n";
                print "  q, quit   - Disconnect and exit\n";
                print "  h, help   - Show this help\n\n";

            } elsif ($input ne '') {
                print "Unknown command. Type 'h' for help.\n";
            }
        }
    }
}
